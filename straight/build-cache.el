
:tanat

"28.0.60"

#s(hash-table size 97 test equal rehash-size 1.5 rehash-threshold 0.8125 data ("org-elpa" ("2021-11-20 16:34:15" nil (:local-repo nil :package "org-elpa" :type git)) "melpa" ("2021-11-20 16:34:15" nil (:type git :host github :repo "melpa/melpa" :build nil :package "melpa" :local-repo "melpa")) "gnu-elpa-mirror" ("2021-11-20 16:34:15" nil (:type git :host github :repo "emacs-straight/gnu-elpa-mirror" :build nil :package "gnu-elpa-mirror" :local-repo "gnu-elpa-mirror")) "el-get" ("2021-11-20 16:34:15" nil (:type git :host github :repo "dimitri/el-get" :build nil :files ("*.el" ("recipes" "recipes/el-get.rcp") "methods" "el-get-pkg.el") :flavor melpa :package "el-get" :local-repo "el-get")) "emacsmirror-mirror" ("2021-11-20 16:34:15" nil (:type git :host github :repo "emacs-straight/emacsmirror-mirror" :build nil :package "emacsmirror-mirror" :local-repo "emacsmirror-mirror")) "straight" ("2021-11-20 16:34:15" ("emacs") (:type git :host github :repo "raxod502/straight.el" :files ("straight*.el") :branch "master" :package "straight" :local-repo "straight.el")) "use-package" ("2021-11-20 16:34:15" ("emacs" "bind-key") (:type git :flavor melpa :files (:defaults (:exclude "bind-key.el" "bind-chord.el" "use-package-chords.el" "use-package-ensure-system-package.el") "use-package-pkg.el") :host github :repo "jwiegley/use-package" :package "use-package" :local-repo "use-package")) "bind-key" ("2021-11-20 16:34:15" nil (:flavor melpa :files ("bind-key.el" "bind-key-pkg.el") :package "bind-key" :local-repo "use-package" :type git :repo "jwiegley/use-package" :host github)) "setup" ("2021-11-20 16:34:15" ("emacs") (:type git :host nil :repo "https://git.sr.ht/~pkal/setup" :files (:defaults) :package "setup" :local-repo "setup")) "no-littering" ("2021-11-20 16:34:15" ("cl-lib") (:straight nil :flavor melpa :repo "emacscollective/no-littering" :host github :package "no-littering" :type git :local-repo "no-littering")) "undo-tree" ("2021-11-20 16:34:15" nil (:straight nil :files ("*" (:exclude ".git")) :repo "emacs-straight/undo-tree" :host github :package "undo-tree" :type git :local-repo "undo-tree")) "evil" ("2021-11-20 16:34:15" ("emacs" "goto-chg" "cl-lib") (:straight nil :files (:defaults "doc/build/texinfo/evil.texi" (:exclude "evil-test-helpers.el") "evil-pkg.el") :flavor melpa :repo "emacs-evil/evil" :host github :package "evil" :type git :local-repo "evil")) "goto-chg" ("2021-11-20 16:34:15" ("emacs") (:type git :flavor melpa :host github :repo "emacs-evil/goto-chg" :package "goto-chg" :local-repo "goto-chg")) "evil-collection" ("2021-11-20 16:34:15" ("emacs" "evil" "annalist") (:straight nil :files (:defaults "modes" "evil-collection-pkg.el") :flavor melpa :repo "emacs-evil/evil-collection" :host github :package "evil-collection" :type git :local-repo "evil-collection")) "annalist" ("2021-11-20 16:34:15" ("emacs" "cl-lib") (:type git :flavor melpa :host github :repo "noctuid/annalist.el" :package "annalist" :local-repo "annalist.el")) "diminish" ("2021-11-20 16:34:15" ("emacs") (:straight nil :flavor melpa :repo "myrjola/diminish.el" :host github :package "diminish" :type git :local-repo "diminish.el")) "which-key" ("2021-11-20 16:34:15" ("emacs") (:straight nil :flavor melpa :repo "justbur/emacs-which-key" :host github :package "which-key" :type git :local-repo "emacs-which-key")) "general" ("2021-11-20 16:34:15" ("emacs" "cl-lib") (:straight nil :flavor melpa :repo "noctuid/general.el" :host github :package "general" :type git :local-repo "general.el")) "spacegray-theme" ("2021-11-20 16:34:16" ("emacs") (:straight nil :flavor melpa :repo "bruce/emacs-spacegray-theme" :host github :package "spacegray-theme" :type git :local-repo "emacs-spacegray-theme")) "doom-themes" ("2021-11-20 16:34:16" ("emacs" "cl-lib") (:straight nil :files (:defaults "themes/*.el" "doom-themes-pkg.el") :flavor melpa :repo "hlissner/emacs-doom-themes" :host github :package "doom-themes" :type git :local-repo "emacs-doom-themes")) "emojify" ("2021-11-20 16:34:16" ("seq" "ht" "emacs") (:straight nil :files (:defaults "data" "images" "emojify-pkg.el") :flavor melpa :repo "iqbalansari/emacs-emojify" :host github :package "emojify" :type git :local-repo "emacs-emojify")) "ht" ("2021-11-20 16:34:16" ("dash") (:type git :flavor melpa :files ("ht.el" "ht-pkg.el") :host github :repo "Wilfred/ht.el" :package "ht" :local-repo "ht.el")) "dash" ("2021-11-20 16:34:16" ("emacs") (:type git :flavor melpa :files ("dash.el" "dash.texi" "dash-pkg.el") :host github :repo "magnars/dash.el" :package "dash" :local-repo "dash.el")) "minions" ("2021-11-20 16:34:16" ("emacs") (:straight nil :flavor melpa :repo "tarsius/minions" :host github :package "minions" :type git :local-repo "minions")) "doom-modeline" ("2021-11-20 16:34:16" ("emacs" "all-the-icons" "shrink-path" "dash") (:straight nil :flavor melpa :repo "seagle0128/doom-modeline" :host github :package "doom-modeline" :type git :local-repo "doom-modeline")) "all-the-icons" ("2021-11-20 16:34:16" ("emacs") (:type git :flavor melpa :files (:defaults "data" "all-the-icons-pkg.el") :host github :repo "domtronn/all-the-icons.el" :package "all-the-icons" :local-repo "all-the-icons.el")) "shrink-path" ("2021-11-20 16:34:16" ("emacs" "s" "dash" "f") (:type git :flavor melpa :host gitlab :repo "bennya/shrink-path.el" :package "shrink-path" :local-repo "shrink-path.el")) "s" ("2021-11-20 16:34:16" nil (:type git :flavor melpa :files ("s.el" "s-pkg.el") :host github :repo "magnars/s.el" :package "s" :local-repo "s.el")) "f" ("2021-11-20 16:34:16" ("s" "dash") (:type git :flavor melpa :files ("f.el" "f-pkg.el") :host github :repo "rejeep/f.el" :package "f" :local-repo "f.el")) "perspective" ("2021-11-20 16:34:16" ("emacs" "cl-lib") (:straight nil :flavor melpa :repo "nex3/perspective-el" :host github :package "perspective" :type git :local-repo "perspective-el")) "alert" ("2021-11-20 16:34:16" ("gntp" "log4e" "cl-lib") (:straight nil :flavor melpa :repo "jwiegley/alert" :host github :package "alert" :type git :local-repo "alert")) "gntp" ("2021-11-20 16:34:16" nil (:type git :flavor melpa :host github :repo "tekai/gntp.el" :package "gntp" :local-repo "gntp.el")) "log4e" ("2021-11-20 16:34:16" nil (:type git :flavor melpa :host github :repo "aki2o/log4e" :package "log4e" :local-repo "log4e")) "super-save" ("2021-11-20 16:34:16" ("emacs") (:straight nil :flavor melpa :repo "bbatsov/super-save" :host github :package "super-save" :type git :local-repo "super-save")) "evil-nerd-commenter" ("2021-11-20 16:34:16" ("emacs") (:straight nil :flavor melpa :repo "redguardtoo/evil-nerd-commenter" :host github :package "evil-nerd-commenter" :type git :local-repo "evil-nerd-commenter")) "ws-butler" ("2021-11-20 16:34:16" nil (:straight nil :flavor melpa :repo "lewang/ws-butler" :host github :package "ws-butler" :type git :local-repo "ws-butler")) "parinfer" ("2021-11-20 16:34:16" ("dash" "cl-lib") (:guix "emacs-parinfer-mode" :straight nil :flavor melpa :repo "DogLooksGood/parinfer-mode" :host github :package "parinfer" :type git :local-repo "parinfer-mode")) "origami" ("2021-11-20 16:34:16" ("s" "dash" "emacs" "cl-lib") (:guix "emacs-origami-el" :straight nil :flavor melpa :repo "gregsexton/origami.el" :host github :package "origami" :type git :local-repo "origami.el")) "dotcrafter" ("2021-11-20 16:34:16" nil (:host github :repo "daviwil/dotcrafter.el" :branch "main" :straight nil :package "dotcrafter" :type git :local-repo "dotcrafter.el")) "hydra" ("2021-11-20 16:34:16" ("cl-lib" "lv") (:straight nil :files (:defaults (:exclude "lv.el") "hydra-pkg.el") :flavor melpa :repo "abo-abo/hydra" :host github :package "hydra" :type git :local-repo "hydra")) "lv" ("2021-11-20 16:34:16" nil (:flavor melpa :files ("lv.el" "lv-pkg.el") :package "lv" :local-repo "hydra" :type git :repo "abo-abo/hydra" :host github)) "corfu" ("2021-11-20 16:34:16" ("emacs") (:host github :repo "minad/corfu" :straight nil :package "corfu" :type git :local-repo "corfu")) "orderless" ("2021-11-20 16:34:16" ("emacs") (:straight nil :flavor melpa :repo "oantolin/orderless" :host github :package "orderless" :type git :local-repo "orderless")) "consult" ("2021-11-20 16:34:16" ("emacs") (:straight nil :files (:defaults (:exclude "consult-flycheck.el" "consult-selectrum.el") "consult-pkg.el") :flavor melpa :repo "minad/consult" :host github :package "consult" :type git :local-repo "consult")) "marginalia" ("2021-11-20 16:34:16" ("emacs") (:straight nil :flavor melpa :repo "minad/marginalia" :host github :package "marginalia" :type git :local-repo "marginalia")) "embark" ("2021-11-20 16:34:16" ("emacs") (:straight nil :files ("embark.el" "embark-pkg.el") :flavor melpa :repo "oantolin/embark" :host github :package "embark" :type git :local-repo "embark")) "avy" ("2021-11-20 16:34:16" ("emacs" "cl-lib") (:straight nil :flavor melpa :repo "abo-abo/avy" :host github :package "avy" :type git :local-repo "avy")) "bufler" ("2021-11-20 16:34:16" ("emacs" "dash" "dash-functional" "f" "pretty-hydra" "magit-section") (:straight nil :files (:defaults (:exclude "helm-bufler.el") "bufler-pkg.el") :flavor melpa :repo "alphapapa/bufler.el" :host github :package "bufler" :type git :local-repo "bufler.el")) "dash-functional" ("2021-11-20 16:34:16" ("emacs" "dash") (:flavor melpa :files ("dash-functional.el" "dash-functional-pkg.el") :package "dash-functional" :local-repo "dash.el" :type git :repo "magnars/dash.el" :host github)) "pretty-hydra" ("2021-11-20 16:34:16" ("hydra" "s" "dash" "dash-functional" "emacs") (:type git :flavor melpa :files ("pretty-hydra.el" "pretty-hydra-pkg.el") :host github :repo "jerrypnz/major-mode-hydra.el" :package "pretty-hydra" :local-repo "major-mode-hydra.el")) "magit-section" ("2021-11-20 16:34:16" ("emacs" "dash") (:type git :flavor melpa :files ("lisp/magit-section.el" "Documentation/magit-section.texi" "magit-section-pkg.el") :host github :repo "magit/magit" :package "magit-section" :local-repo "magit")) "default-text-scale" ("2021-11-20 16:34:16" ("emacs") (:straight nil :flavor melpa :repo "purcell/default-text-scale" :host github :package "default-text-scale" :type git :local-repo "default-text-scale")) "ace-window" ("2021-11-20 16:34:16" ("avy") (:straight nil :flavor melpa :repo "abo-abo/ace-window" :host github :package "ace-window" :type git :local-repo "ace-window")) "visual-fill-column" ("2021-11-20 16:34:16" ("emacs") (:straight nil :flavor melpa :repo "joostkremers/visual-fill-column" :host github :package "visual-fill-column" :type git :local-repo "visual-fill-column")) "popper" ("2021-11-20 16:34:16" ("emacs") (:host github :repo "karthink/popper" :build (:not autoloads) :straight nil :package "popper" :type git :local-repo "popper")) "password-store" ("2021-11-20 16:34:16" ("emacs" "s" "with-editor" "auth-source-pass") (:straight nil :files ("contrib/emacs/*.el" "password-store-pkg.el") :flavor melpa :repo "zx2c4/password-store" :host github :package "password-store" :type git :local-repo "password-store")) "with-editor" ("2021-11-20 16:34:16" ("emacs") (:type git :flavor melpa :host github :repo "magit/with-editor" :package "with-editor" :local-repo "with-editor")) "auth-source-pass" ("2021-11-20 16:34:16" ("emacs") (:straight nil :flavor melpa :repo "DamienCassou/auth-source-pass" :host github :package "auth-source-pass" :type git :local-repo "auth-source-pass")) "oauth2" ("2021-11-20 16:34:16" ("cl-lib" "nadvice") (:straight nil :files ("*" (:exclude ".git")) :repo "emacs-straight/oauth2" :host github :package "oauth2" :type git :local-repo "oauth2")) "all-the-icons-dired" ("2021-11-20 16:34:16" ("emacs" "all-the-icons") (:straight nil :flavor melpa :repo "jtbm37/all-the-icons-dired" :host github :package "all-the-icons-dired" :type git :local-repo "all-the-icons-dired")) "dired-single" ("2021-11-20 16:34:16" nil (:straight nil :flavor melpa :repo "crocket/dired-single" :host github :package "dired-single" :type git :local-repo "dired-single")) "dired-ranger" ("2021-11-20 16:34:16" ("dash" "dired-hacks-utils") (:straight nil :files ("dired-ranger.el" "dired-ranger-pkg.el") :flavor melpa :repo "Fuco1/dired-hacks" :host github :package "dired-ranger" :type git :local-repo "dired-hacks")) "dired-hacks-utils" ("2021-11-20 16:34:16" ("dash") (:flavor melpa :files ("dired-hacks-utils.el" "dired-hacks-utils-pkg.el") :package "dired-hacks-utils" :local-repo "dired-hacks" :type git :repo "Fuco1/dired-hacks" :host github)) "dired-collapse" ("2021-11-20 16:34:16" ("dash" "f" "dired-hacks-utils") (:straight nil :files ("dired-collapse.el" "dired-collapse-pkg.el") :flavor melpa :repo "Fuco1/dired-hacks" :host github :package "dired-collapse" :type git :local-repo "dired-hacks")) "dired-rainbow" ("2021-11-20 16:34:16" ("dash" "dired-hacks-utils") (:straight nil :files ("dired-rainbow.el" "dired-rainbow-pkg.el") :flavor melpa :repo "Fuco1/dired-hacks" :host github :package "dired-rainbow" :type git :local-repo "dired-hacks")) "openwith" ("2021-11-20 16:34:16" nil (:straight nil :flavor melpa :repo "jpkotta/openwith" :host github :package "openwith" :type git :local-repo "openwith")) "org" ("2021-11-20 16:34:16" nil (:straight nil :build (:not autoloads) :files (:defaults "lisp/*.el" ("etc/styles/" "etc/styles/*")) :local-repo "org" :pre-build (straight-recipes-org-elpa--build) :repo "https://git.savannah.gnu.org/git/emacs/org-mode.git" :depth full :package "org" :type git)) "org-superstar" ("2021-11-20 16:34:16" ("org" "emacs") (:straight nil :flavor melpa :repo "integral-dw/org-superstar-mode" :host github :package "org-superstar" :type git :local-repo "org-superstar-mode")) "org-pomodoro" ("2021-11-20 16:34:16" ("alert" "cl-lib") (:straight nil :files (:defaults "resources" "org-pomodoro-pkg.el") :flavor melpa :repo "marcinkoziej/org-pomodoro" :host github :package "org-pomodoro" :type git :local-repo "org-pomodoro")) "evil-org" ("2021-11-20 16:34:17" ("emacs" "evil") (:straight nil :flavor melpa :repo "Somelauw/evil-org-mode" :host github :package "evil-org" :type git :local-repo "evil-org-mode")) "org-make-toc" ("2021-11-20 16:34:17" ("emacs" "dash" "s" "org") (:straight nil :flavor melpa :repo "alphapapa/org-make-toc" :host github :package "org-make-toc" :type git :local-repo "org-make-toc")) "org-present" ("2021-11-20 16:34:17" ("org") (:straight nil :flavor melpa :repo "rlister/org-present" :host github :package "org-present" :type git :local-repo "org-present")) "org-roam" ("2021-11-20 16:34:17" ("emacs" "dash" "f" "s" "org" "emacsql" "emacsql-sqlite3") (:straight nil :flavor melpa :repo "org-roam/org-roam" :host github :package "org-roam" :type git :local-repo "org-roam")) "emacsql" ("2021-11-20 16:34:17" ("emacs") (:type git :flavor melpa :files ("emacsql.el" "emacsql-compiler.el" "emacsql-system.el" "README.md" "emacsql-pkg.el") :host github :repo "skeeto/emacsql" :package "emacsql" :local-repo "emacsql")) "emacsql-sqlite3" ("2021-11-20 16:34:17" ("emacs" "emacsql") (:type git :flavor melpa :host github :repo "cireu/emacsql-sqlite3" :package "emacsql-sqlite3" :local-repo "emacsql-sqlite3")) "guix" ("2021-11-20 16:34:17" ("emacs" "dash" "geiser" "bui" "magit-popup" "edit-indirect") (:straight nil :files ("elisp/*.el" "doc/*.texi" ("images" "images/*.svg") ("scheme" "scheme/*") (:exclude "scheme/Makefile.am") "guix-pkg.el") :flavor melpa :repo "alezost/guix.el" :host github :package "guix" :type git :local-repo "guix.el")) "geiser" ("2021-11-20 16:34:17" nil (:type git :flavor melpa :files ("elisp/*.el" "elisp/geiser-version.el.in" "doc/*.texi" ("bin" "bin/*") (:exclude "bin/Makefile.am") ("scheme" "scheme/*") (:exclude "scheme/Makefile.am") "geiser-pkg.el") :host gitlab :repo "jaor/geiser" :package "geiser" :local-repo "geiser")) "bui" ("2021-11-20 16:34:17" ("emacs" "dash") (:type git :flavor melpa :host github :repo "alezost/bui.el" :package "bui" :local-repo "bui.el")) "magit-popup" ("2021-11-20 16:34:17" ("emacs" "dash") (:type git :flavor melpa :host github :repo "magit/magit-popup" :package "magit-popup" :local-repo "magit-popup")) "edit-indirect" ("2021-11-20 16:34:17" ("emacs") (:type git :flavor melpa :host github :repo "Fanael/edit-indirect" :package "edit-indirect" :local-repo "edit-indirect")) "daemons" ("2021-11-20 16:34:17" ("emacs") (:straight nil :flavor melpa :repo "cbowdon/daemons.el" :host github :package "daemons" :type git :local-repo "daemons.el")) "pulseaudio-control" ("2021-11-20 16:34:17" nil (:straight nil :flavor melpa :repo "flexibeast/pulseaudio-control" :host github :package "pulseaudio-control" :type git :local-repo "pulseaudio-control"))))

#s(hash-table size 97 test equal rehash-size 1.5 rehash-threshold 0.8125 data ("straight" ((straight straight-autoloads straight-x) (autoload 'straight-remove-unused-repos "straight" "Remove unused repositories from the repos directory.
A repo is considered \"unused\" if it was not explicitly requested via
`straight-use-package' during the current Emacs session.
If FORCE is non-nil do not prompt before deleting repos.

(fn &optional FORCE)" t nil) (autoload 'straight-get-recipe "straight" "Interactively select a recipe from one of the recipe repositories.
All recipe repositories in `straight-recipe-repositories' will
first be cloned. After the recipe is selected, it will be copied
to the kill ring. With a prefix argument, first prompt for a
recipe repository to search. Only that repository will be
cloned.

From Lisp code, SOURCES should be a subset of the symbols in
`straight-recipe-repositories'. Only those recipe repositories
are cloned and searched. If it is nil or omitted, then the value
of `straight-recipe-repositories' is used. If SOURCES is the
symbol `interactive', then the user is prompted to select a
recipe repository, and a list containing that recipe repository
is used for the value of SOURCES. ACTION may be `copy' (copy
recipe to the kill ring), `insert' (insert at point), or nil (no
action, just return it).

(fn &optional SOURCES ACTION)" t nil) (autoload 'straight-visit-package-website "straight" "Interactively select a recipe, and visit the package's website." t nil) (autoload 'straight-use-package "straight" "Register, clone, build, and activate a package and its dependencies.
This is the main entry point to the functionality of straight.el.

MELPA-STYLE-RECIPE is either a symbol naming a package, or a list
whose car is a symbol naming a package and whose cdr is a
property list containing e.g. `:type', `:local-repo', `:files',
and VC backend specific keywords.

First, the package recipe is registered with straight.el. If
NO-CLONE is a function, then it is called with two arguments: the
package name as a string, and a boolean value indicating whether
the local repository for the package is available. In that case,
the return value of the function is used as the value of NO-CLONE
instead. In any case, if NO-CLONE is non-nil, then processing
stops here.

Otherwise, the repository is cloned, if it is missing. If
NO-BUILD is a function, then it is called with one argument: the
package name as a string. In that case, the return value of the
function is used as the value of NO-BUILD instead. In any case,
if NO-BUILD is non-nil, then processing halts here. Otherwise,
the package is built and activated. Note that if the package
recipe has a nil `:build' entry, then NO-BUILD is ignored
and processing always stops before building and activation
occurs.

CAUSE is a string explaining the reason why
`straight-use-package' has been called. It is for internal use
only, and is used to construct progress messages. INTERACTIVE is
non-nil if the function has been called interactively. It is for
internal use only, and is used to determine whether to show a
hint about how to install the package permanently.

Return non-nil if package was actually installed, and nil
otherwise (this can only happen if NO-CLONE is non-nil).

(fn MELPA-STYLE-RECIPE &optional NO-CLONE NO-BUILD CAUSE INTERACTIVE)" t nil) (autoload 'straight-register-package "straight" "Register a package without cloning, building, or activating it.
This function is equivalent to calling `straight-use-package'
with a non-nil argument for NO-CLONE. It is provided for
convenience. MELPA-STYLE-RECIPE is as for
`straight-use-package'.

(fn MELPA-STYLE-RECIPE)" nil nil) (autoload 'straight-use-package-no-build "straight" "Register and clone a package without building it.
This function is equivalent to calling `straight-use-package'
with nil for NO-CLONE but a non-nil argument for NO-BUILD. It is
provided for convenience. MELPA-STYLE-RECIPE is as for
`straight-use-package'.

(fn MELPA-STYLE-RECIPE)" nil nil) (autoload 'straight-use-package-lazy "straight" "Register, build, and activate a package if it is already cloned.
This function is equivalent to calling `straight-use-package'
with symbol `lazy' for NO-CLONE. It is provided for convenience.
MELPA-STYLE-RECIPE is as for `straight-use-package'.

(fn MELPA-STYLE-RECIPE)" nil nil) (autoload 'straight-use-recipes "straight" "Register a recipe repository using MELPA-STYLE-RECIPE.
This registers the recipe and builds it if it is already cloned.
Note that you probably want the recipe for a recipe repository to
include a nil `:build' property, to unconditionally
inhibit the build phase.

This function also adds the recipe repository to
`straight-recipe-repositories', at the end of the list.

(fn MELPA-STYLE-RECIPE)" nil nil) (autoload 'straight-override-recipe "straight" "Register MELPA-STYLE-RECIPE as a recipe override.
This puts it in `straight-recipe-overrides', depending on the
value of `straight-current-profile'.

(fn MELPA-STYLE-RECIPE)" nil nil) (autoload 'straight-check-package "straight" "Rebuild a PACKAGE if it has been modified.
PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'. See also `straight-rebuild-package' and
`straight-check-all'.

(fn PACKAGE)" t nil) (autoload 'straight-check-all "straight" "Rebuild any packages that have been modified.
See also `straight-rebuild-all' and `straight-check-package'.
This function should not be called during init." t nil) (autoload 'straight-rebuild-package "straight" "Rebuild a PACKAGE.
PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'. With prefix argument RECURSIVE, rebuild
all dependencies as well. See also `straight-check-package' and
`straight-rebuild-all'.

(fn PACKAGE &optional RECURSIVE)" t nil) (autoload 'straight-rebuild-all "straight" "Rebuild all packages.
See also `straight-check-all' and `straight-rebuild-package'." t nil) (autoload 'straight-prune-build-cache "straight" "Prune the build cache.
This means that only packages that were built in the last init
run and subsequent interactive session will remain; other
packages will have their build mtime information and any cached
autoloads discarded." nil nil) (autoload 'straight-prune-build-directory "straight" "Prune the build directory.
This means that only packages that were built in the last init
run and subsequent interactive session will remain; other
packages will have their build directories deleted." nil nil) (autoload 'straight-prune-build "straight" "Prune the build cache and build directory.
This means that only packages that were built in the last init
run and subsequent interactive session will remain; other
packages will have their build mtime information discarded and
their build directories deleted." t nil) (autoload 'straight-normalize-package "straight" "Normalize a PACKAGE's local repository to its recipe's configuration.
PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'.

(fn PACKAGE)" t nil) (autoload 'straight-normalize-all "straight" "Normalize all packages. See `straight-normalize-package'.
Return a list of recipes for packages that were not successfully
normalized. If multiple packages come from the same local
repository, only one is normalized.

PREDICATE, if provided, filters the packages that are normalized.
It is called with the package name as a string, and should return
non-nil if the package should actually be normalized.

(fn &optional PREDICATE)" t nil) (autoload 'straight-fetch-package "straight" "Try to fetch a PACKAGE from the primary remote.
PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'. With prefix argument FROM-UPSTREAM,
fetch not just from primary remote but also from upstream (for
forked packages).

(fn PACKAGE &optional FROM-UPSTREAM)" t nil) (autoload 'straight-fetch-package-and-deps "straight" "Try to fetch a PACKAGE and its (transitive) dependencies.
PACKAGE, its dependencies, their dependencies, etc. are fetched
from their primary remotes.

PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'. With prefix argument FROM-UPSTREAM,
fetch not just from primary remote but also from upstream (for
forked packages).

(fn PACKAGE &optional FROM-UPSTREAM)" t nil) (autoload 'straight-fetch-all "straight" "Try to fetch all packages from their primary remotes.
With prefix argument FROM-UPSTREAM, fetch not just from primary
remotes but also from upstreams (for forked packages).

Return a list of recipes for packages that were not successfully
fetched. If multiple packages come from the same local
repository, only one is fetched.

PREDICATE, if provided, filters the packages that are fetched. It
is called with the package name as a string, and should return
non-nil if the package should actually be fetched.

(fn &optional FROM-UPSTREAM PREDICATE)" t nil) (autoload 'straight-merge-package "straight" "Try to merge a PACKAGE from the primary remote.
PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'. With prefix argument FROM-UPSTREAM,
merge not just from primary remote but also from upstream (for
forked packages).

(fn PACKAGE &optional FROM-UPSTREAM)" t nil) (autoload 'straight-merge-package-and-deps "straight" "Try to merge a PACKAGE and its (transitive) dependencies.
PACKAGE, its dependencies, their dependencies, etc. are merged
from their primary remotes.

PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'. With prefix argument FROM-UPSTREAM,
merge not just from primary remote but also from upstream (for
forked packages).

(fn PACKAGE &optional FROM-UPSTREAM)" t nil) (autoload 'straight-merge-all "straight" "Try to merge all packages from their primary remotes.
With prefix argument FROM-UPSTREAM, merge not just from primary
remotes but also from upstreams (for forked packages).

Return a list of recipes for packages that were not successfully
merged. If multiple packages come from the same local
repository, only one is merged.

PREDICATE, if provided, filters the packages that are merged. It
is called with the package name as a string, and should return
non-nil if the package should actually be merged.

(fn &optional FROM-UPSTREAM PREDICATE)" t nil) (autoload 'straight-pull-package "straight" "Try to pull a PACKAGE from the primary remote.
PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'. With prefix argument FROM-UPSTREAM, pull
not just from primary remote but also from upstream (for forked
packages).

(fn PACKAGE &optional FROM-UPSTREAM)" t nil) (autoload 'straight-pull-package-and-deps "straight" "Try to pull a PACKAGE and its (transitive) dependencies.
PACKAGE, its dependencies, their dependencies, etc. are pulled
from their primary remotes.

PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'. With prefix argument FROM-UPSTREAM,
pull not just from primary remote but also from upstream (for
forked packages).

(fn PACKAGE &optional FROM-UPSTREAM)" t nil) (autoload 'straight-pull-all "straight" "Try to pull all packages from their primary remotes.
With prefix argument FROM-UPSTREAM, pull not just from primary
remotes but also from upstreams (for forked packages).

Return a list of recipes for packages that were not successfully
pulled. If multiple packages come from the same local repository,
only one is pulled.

PREDICATE, if provided, filters the packages that are pulled. It
is called with the package name as a string, and should return
non-nil if the package should actually be pulled.

(fn &optional FROM-UPSTREAM PREDICATE)" t nil) (autoload 'straight-push-package "straight" "Push a PACKAGE to its primary remote, if necessary.
PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'.

(fn PACKAGE)" t nil) (autoload 'straight-push-all "straight" "Try to push all packages to their primary remotes.

Return a list of recipes for packages that were not successfully
pushed. If multiple packages come from the same local repository,
only one is pushed.

PREDICATE, if provided, filters the packages that are normalized.
It is called with the package name as a string, and should return
non-nil if the package should actually be normalized.

(fn &optional PREDICATE)" t nil) (autoload 'straight-freeze-versions "straight" "Write version lockfiles for currently activated packages.
This implies first pushing all packages that have unpushed local
changes. If the package management system has been used since the
last time the init-file was reloaded, offer to fix the situation
by reloading the init-file again. If FORCE is
non-nil (interactively, if a prefix argument is provided), skip
all checks and write the lockfile anyway.

Currently, writing version lockfiles requires cloning all lazily
installed packages. Hopefully, this inconvenient requirement will
be removed in the future.

Multiple lockfiles may be written (one for each profile),
according to the value of `straight-profiles'.

(fn &optional FORCE)" t nil) (autoload 'straight-thaw-versions "straight" "Read version lockfiles and restore package versions to those listed." t nil) (autoload 'straight-bug-report "straight" "Test straight.el in a clean environment.
ARGS may be any of the following keywords and their respective values:
  - :pre-bootstrap (Form)...
      Forms evaluated before bootstrapping straight.el
      e.g. (setq straight-repository-branch \"develop\")
      Note this example is already in the default bootstrapping code.

  - :post-bootstrap (Form)...
      Forms evaluated in the testing environment after boostrapping.
      e.g. (straight-use-package '(example :type git :host github))

  - :interactive Boolean
      If nil, the subprocess will immediately exit after the test.
      Output will be printed to `straight-bug-report--process-buffer'
      Otherwise, the subprocess will be interactive.

  - :preserve Boolean
      If non-nil, the test directory is left in the directory stored in the
      variable `temporary-file-directory'. Otherwise, it is
      immediately removed after the test is run.

  - :executable String
      Indicate the Emacs executable to launch.
      Defaults to the path of the current Emacs executable.

  - :raw Boolean
      If non-nil, the raw process output is sent to
      `straight-bug-report--process-buffer'. Otherwise, it is
      formatted as markdown for submitting as an issue.

  - :user-dir String
      If non-nil, the test is run with `user-emacs-directory' set to STRING.
      Otherwise, a temporary directory is created and used.
      Unless absolute, paths are expanded relative to the variable
      `temporary-file-directory'.

ARGS are accessible within the :pre/:post-bootsrap phases via the
locally bound plist, straight-bug-report-args.

(fn &rest ARGS)" nil t) (function-put 'straight-bug-report 'lisp-indent-function '0) (autoload 'straight-dependencies "straight" "Return a list of PACKAGE's dependencies.

(fn &optional PACKAGE)" t nil) (autoload 'straight-dependents "straight" "Return a list PACKAGE's dependents.

(fn &optional PACKAGE)" t nil) (register-definition-prefixes "straight" '("straight-")) (defvar straight-x-pinned-packages nil "List of pinned packages.") (register-definition-prefixes "straight-x" '("straight-x-")) (provide 'straight-autoloads)) "bind-key" ((bind-key bind-key-autoloads) (autoload 'bind-key "bind-key" "Bind KEY-NAME to COMMAND in KEYMAP (`global-map' if not passed).

KEY-NAME may be a vector, in which case it is passed straight to
`define-key'. Or it may be a string to be interpreted as
spelled-out keystrokes, e.g., \"C-c C-z\". See documentation of
`edmacro-mode' for details.

COMMAND must be an interactive function or lambda form.

KEYMAP, if present, should be a keymap variable or symbol.
For example:

  (bind-key \"M-h\" #'some-interactive-function my-mode-map)

  (bind-key \"M-h\" #'some-interactive-function 'my-mode-map)

If PREDICATE is non-nil, it is a form evaluated to determine when
a key should be bound. It must return non-nil in such cases.
Emacs can evaluate this form at any time that it does redisplay
or operates on menu data structures, so you should write it so it
can safely be called at any time.

(fn KEY-NAME COMMAND &optional KEYMAP PREDICATE)" nil t) (autoload 'unbind-key "bind-key" "Unbind the given KEY-NAME, within the KEYMAP (if specified).
See `bind-key' for more details.

(fn KEY-NAME &optional KEYMAP)" nil t) (autoload 'bind-key* "bind-key" "Similar to `bind-key', but overrides any mode-specific bindings.

(fn KEY-NAME COMMAND &optional PREDICATE)" nil t) (autoload 'bind-keys "bind-key" "Bind multiple keys at once.

Accepts keyword arguments:
:map MAP               - a keymap into which the keybindings should be
                         added
:prefix KEY            - prefix key for these bindings
:prefix-map MAP        - name of the prefix map that should be created
                         for these bindings
:prefix-docstring STR  - docstring for the prefix-map variable
:menu-name NAME        - optional menu string for prefix map
:filter FORM           - optional form to determine when bindings apply

The rest of the arguments are conses of keybinding string and a
function symbol (unquoted).

(fn &rest ARGS)" nil t) (autoload 'bind-keys* "bind-key" "

(fn &rest ARGS)" nil t) (autoload 'describe-personal-keybindings "bind-key" "Display all the personal keybindings defined by `bind-key'." t nil) (register-definition-prefixes "bind-key" '("bind-key" "compare-keybindings" "get-binding-description" "override-global-m" "personal-keybindings")) (provide 'bind-key-autoloads)) "use-package" ((use-package-jump use-package use-package-ensure use-package-core use-package-diminish use-package-autoloads use-package-delight use-package-bind-key use-package-lint) (autoload 'use-package-autoload-keymap "use-package-bind-key" "Loads PACKAGE and then binds the key sequence used to invoke
this function to KEYMAP-SYMBOL. It then simulates pressing the
same key sequence a again, so that the next key pressed is routed
to the newly loaded keymap.

This function supports use-package's :bind-keymap keyword. It
works by binding the given key sequence to an invocation of this
function for a particular keymap. The keymap is expected to be
defined by the package. In this way, loading the package is
deferred until the prefix key sequence is pressed.

(fn KEYMAP-SYMBOL PACKAGE OVERRIDE)" nil nil) (autoload 'use-package-normalize-binder "use-package-bind-key" "

(fn NAME KEYWORD ARGS)" nil nil) (defalias 'use-package-normalize/:bind 'use-package-normalize-binder) (defalias 'use-package-normalize/:bind* 'use-package-normalize-binder) (defalias 'use-package-autoloads/:bind 'use-package-autoloads-mode) (defalias 'use-package-autoloads/:bind* 'use-package-autoloads-mode) (autoload 'use-package-handler/:bind "use-package-bind-key" "

(fn NAME KEYWORD ARGS REST STATE &optional BIND-MACRO)" nil nil) (defalias 'use-package-normalize/:bind-keymap 'use-package-normalize-binder) (defalias 'use-package-normalize/:bind-keymap* 'use-package-normalize-binder) (autoload 'use-package-handler/:bind-keymap "use-package-bind-key" "

(fn NAME KEYWORD ARGS REST STATE &optional OVERRIDE)" nil nil) (autoload 'use-package-handler/:bind-keymap* "use-package-bind-key" "

(fn NAME KEYWORD ARG REST STATE)" nil nil) (register-definition-prefixes "use-package-bind-key" '("use-package-handler/:bind*")) (autoload 'use-package "use-package-core" "Declare an Emacs package by specifying a group of configuration options.

For full documentation, please see the README file that came with
this file.  Usage:

  (use-package package-name
     [:keyword [option]]...)

:init            Code to run before PACKAGE-NAME has been loaded.
:config          Code to run after PACKAGE-NAME has been loaded.  Note that
                 if loading is deferred for any reason, this code does not
                 execute until the lazy load has occurred.
:preface         Code to be run before everything except `:disabled'; this
                 can be used to define functions for use in `:if', or that
                 should be seen by the byte-compiler.

:mode            Form to be added to `auto-mode-alist'.
:magic           Form to be added to `magic-mode-alist'.
:magic-fallback  Form to be added to `magic-fallback-mode-alist'.
:interpreter     Form to be added to `interpreter-mode-alist'.

:commands        Define autoloads for commands that will be defined by the
                 package.  This is useful if the package is being lazily
                 loaded, and you wish to conditionally call functions in your
                 `:init' block that are defined in the package.
:hook            Specify hook(s) to attach this package to.

:bind            Bind keys, and define autoloads for the bound commands.
:bind*           Bind keys, and define autoloads for the bound commands,
                 *overriding all minor mode bindings*.
:bind-keymap     Bind a key prefix to an auto-loaded keymap defined in the
                 package.  This is like `:bind', but for keymaps.
:bind-keymap*    Like `:bind-keymap', but overrides all minor mode bindings

:defer           Defer loading of a package -- this is implied when using
                 `:commands', `:bind', `:bind*', `:mode', `:magic', `:hook',
                 `:magic-fallback', or `:interpreter'.  This can be an integer,
                 to force loading after N seconds of idle time, if the package
                 has not already been loaded.
:after           Delay the use-package declaration until after the named modules
                 have loaded. Once load, it will be as though the use-package
                 declaration (without `:after') had been seen at that moment.
:demand          Prevent the automatic deferred loading introduced by constructs
                 such as `:bind' (see `:defer' for the complete list).

:if EXPR         Initialize and load only if EXPR evaluates to a non-nil value.
:disabled        The package is ignored completely if this keyword is present.
:defines         Declare certain variables to silence the byte-compiler.
:functions       Declare certain functions to silence the byte-compiler.
:load-path       Add to the `load-path' before attempting to load the package.
:diminish        Support for diminish.el (if installed).
:delight         Support for delight.el (if installed).
:custom          Call `custom-set' or `set-default' with each variable
                 definition without modifying the Emacs `custom-file'.
                 (compare with `custom-set-variables').
:custom-face     Call `customize-set-faces' with each face definition.
:ensure          Loads the package using package.el if necessary.
:pin             Pin the package to an archive.

(fn NAME &rest ARGS)" nil t) (function-put 'use-package 'lisp-indent-function '1) (register-definition-prefixes "use-package-core" '("use-package-")) (autoload 'use-package-normalize/:delight "use-package-delight" "Normalize arguments to delight.

(fn NAME KEYWORD ARGS)" nil nil) (autoload 'use-package-handler/:delight "use-package-delight" "

(fn NAME KEYWORD ARGS REST STATE)" nil nil) (register-definition-prefixes "use-package-delight" '("use-package-normalize-delight")) (autoload 'use-package-normalize/:diminish "use-package-diminish" "

(fn NAME KEYWORD ARGS)" nil nil) (autoload 'use-package-handler/:diminish "use-package-diminish" "

(fn NAME KEYWORD ARG REST STATE)" nil nil) (register-definition-prefixes "use-package-diminish" '("use-package-normalize-diminish")) (autoload 'use-package-normalize/:ensure "use-package-ensure" "

(fn NAME KEYWORD ARGS)" nil nil) (autoload 'use-package-handler/:ensure "use-package-ensure" "

(fn NAME KEYWORD ENSURE REST STATE)" nil nil) (register-definition-prefixes "use-package-ensure" '("use-package-")) (autoload 'use-package-jump-to-package-form "use-package-jump" "Attempt to find and jump to the `use-package' form that loaded
PACKAGE. This will only find the form if that form actually
required PACKAGE. If PACKAGE was previously required then this
function will jump to the file that originally required PACKAGE
instead.

(fn PACKAGE)" t nil) (register-definition-prefixes "use-package-jump" '("use-package-find-require")) (autoload 'use-package-lint "use-package-lint" "Check for errors in use-package declarations.
For example, if the module's `:if' condition is met, but even
with the specified `:load-path' the module cannot be found." t nil) (register-definition-prefixes "use-package-lint" '("use-package-lint-declaration")) (provide 'use-package-autoloads)) "setup" ((setup setup-autoloads) (autoload 'setup-make-docstring "setup" "Return a docstring for `setup'." nil nil) (autoload 'setup "setup" "Configure feature or subsystem NAME.
BODY may contain special forms defined by `setup-define', but
will otherwise just be evaluated as is.
NAME may also be a macro, if it can provide a symbol.

(fn NAME &rest BODY)" nil t) (function-put 'setup 'lisp-indent-function '1) (put 'setup 'function-documentation '(setup-make-docstring)) (register-definition-prefixes "setup" '("setup-")) (provide 'setup-autoloads)) "no-littering" ((no-littering no-littering-autoloads) (autoload 'no-littering-expand-etc-file-name "no-littering" "Expand filename FILE relative to `no-littering-etc-directory'.

(fn FILE)" nil nil) (autoload 'no-littering-expand-var-file-name "no-littering" "Expand filename FILE relative to `no-littering-var-directory'.

(fn FILE)" nil nil) (register-definition-prefixes "no-littering" '("no-littering-")) (provide 'no-littering-autoloads)) "undo-tree" ((undo-tree-autoloads undo-tree) (autoload 'undo-tree-mode "undo-tree" "Toggle undo-tree mode.
With no argument, this command toggles the mode.
A positive prefix argument turns the mode on.
A negative prefix argument turns it off.

This is a minor mode.  If called interactively, toggle the
`Undo-Tree mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `undo-tree-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

Undo-tree-mode replaces Emacs' standard undo feature with a more
powerful yet easier to use version, that treats the undo history
as what it is: a tree.

The following keys are available in `undo-tree-mode':

  \\{undo-tree-map}

Within the undo-tree visualizer, the following keys are available:

  \\{undo-tree-visualizer-mode-map}

(fn &optional ARG)" t nil) (put 'global-undo-tree-mode 'globalized-minor-mode t) (defvar global-undo-tree-mode nil "Non-nil if Global Undo-Tree mode is enabled.
See the `global-undo-tree-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-undo-tree-mode'.") (custom-autoload 'global-undo-tree-mode "undo-tree" nil) (autoload 'global-undo-tree-mode "undo-tree" "Toggle Undo-Tree mode in all buffers.
With prefix ARG, enable Global Undo-Tree mode if ARG is positive;
otherwise, disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Undo-Tree mode is enabled in all buffers where
`turn-on-undo-tree-mode' would do it.

See `undo-tree-mode' for more information on Undo-Tree mode.

(fn &optional ARG)" t nil) (register-definition-prefixes "undo-tree" '("*undo-tree-id-counter*" "buffer-undo-tree" "turn-on-undo-tree-mode" "undo-")) (provide 'undo-tree-autoloads)) "goto-chg" ((goto-chg-autoloads goto-chg) (autoload 'goto-last-change "goto-chg" "Go to the point where the last edit was made in the current buffer.
Repeat the command to go to the second last edit, etc.

To go back to more recent edit, the reverse of this command, use \\[goto-last-change-reverse]
or precede this command with \\[universal-argument] - (minus).

It does not go to the same point twice even if there has been many edits
there. I call the minimal distance between distinguishable edits \"span\".
Set variable `glc-default-span' to control how close is \"the same point\".
Default span is 8.
The span can be changed temporarily with \\[universal-argument] right before \\[goto-last-change]:
\\[universal-argument] <NUMBER> set current span to that number,
\\[universal-argument] (no number) multiplies span by 4, starting with default.
The so set span remains until it is changed again with \\[universal-argument], or the consecutive
repetition of this command is ended by any other command.

When span is zero (i.e. \\[universal-argument] 0) subsequent \\[goto-last-change] visits each and
every point of edit and a message shows what change was made there.
In this case it may go to the same point twice.

This command uses undo information. If undo is disabled, so is this command.
At times, when undo information becomes too large, the oldest information is
discarded. See variable `undo-limit'.

(fn ARG)" t nil) (autoload 'goto-last-change-reverse "goto-chg" "Go back to more recent changes after \\[goto-last-change] have been used.
See `goto-last-change' for use of prefix argument.

(fn ARG)" t nil) (register-definition-prefixes "goto-chg" '("glc-")) (provide 'goto-chg-autoloads)) "evil" ((evil evil-core evil-repeat evil-search evil-pkg evil-development evil-digraphs evil-states evil-command-window evil-maps evil-types evil-autoloads evil-jumps evil-keybindings evil-common evil-integration evil-macros evil-commands evil-vars evil-ex) (register-definition-prefixes "evil-command-window" '("evil-")) (register-definition-prefixes "evil-commands" '("evil-")) (register-definition-prefixes "evil-common" '("bounds-of-evil-" "evil-" "forward-evil-")) (autoload 'evil-mode "evil" nil t) (register-definition-prefixes "evil-core" '("evil-" "turn-o")) (register-definition-prefixes "evil-digraphs" '("evil-digraph")) (register-definition-prefixes "evil-ex" '("evil-")) (register-definition-prefixes "evil-integration" '("evil-")) (register-definition-prefixes "evil-jumps" '("evil-")) (register-definition-prefixes "evil-macros" '("evil-")) (register-definition-prefixes "evil-maps" '("evil-")) (register-definition-prefixes "evil-repeat" '("evil-")) (register-definition-prefixes "evil-search" '("evil-")) (register-definition-prefixes "evil-states" '("evil-")) (register-definition-prefixes "evil-types" '("evil-ex-get-optional-register-and-count")) (register-definition-prefixes "evil-vars" '("evil-")) (provide 'evil-autoloads)) "annalist" ((annalist annalist-autoloads) (autoload 'annalist-record "annalist" "In the store for ANNALIST, TYPE, and LOCAL, record RECORD.
ANNALIST should correspond to the package/user recording this information (e.g.
'general, 'me, etc.). TYPE is the type of information being recorded (e.g.
'keybindings). LOCAL corresponds to whether to store RECORD only for the current
buffer. This information together is used to select where RECORD should be
stored in and later retrieved from with `annalist-describe'. RECORD should be a
list of items to record and later print as org headings and column entries in a
single row. If PLIST is non-nil, RECORD should be a plist instead of an ordered
list (e.g. '(keymap org-mode-map key \"C-c a\" ...)). The plist keys should be
the symbols used for the definition of TYPE.

(fn ANNALIST TYPE RECORD &key LOCAL PLIST)" nil nil) (autoload 'annalist-describe "annalist" "Describe information recorded by ANNALIST for TYPE.
For example: (annalist-describe 'general 'keybindings) If VIEW is non-nil, use
those settings for displaying recorded information instead of the defaults.

(fn ANNALIST TYPE &optional VIEW)" nil nil) (register-definition-prefixes "annalist" '("annalist-")) (provide 'annalist-autoloads)) "evil-collection" ((evil-collection evil-collection-autoloads) (autoload 'evil-collection-translate-key "evil-collection" "Translate keys in the keymap(s) corresponding to STATES and KEYMAPS.
STATES should be the name of an evil state, a list of states, or nil. KEYMAPS
should be a symbol corresponding to the keymap to make the translations in or a
list of keymap symbols. Like `evil-define-key', when a keymap does not exist,
the keybindings will be deferred until the keymap is defined, so
`with-eval-after-load' is not necessary. TRANSLATIONS corresponds to a list of
key replacement pairs. For example, specifying \"a\" \"b\" will bind \"a\" to
\"b\"'s definition in the keymap. Specifying nil as a replacement will unbind a
key. If DESTRUCTIVE is nil, a backup of the keymap will be stored on the initial
invocation, and future invocations will always look up keys in the backup
keymap. When no TRANSLATIONS are given, this function will only create the
backup keymap without making any translations. On the other hand, if DESTRUCTIVE
is non-nil, the keymap will be destructively altered without creating a backup.
For example, calling this function multiple times with \"a\" \"b\" \"b\" \"a\"
would continue to swap and unswap the definitions of these keys. This means that
when DESTRUCTIVE is non-nil, all related swaps/cycles should be done in the same
invocation.

(fn STATES KEYMAPS &rest TRANSLATIONS &key DESTRUCTIVE &allow-other-keys)" nil nil) (function-put 'evil-collection-translate-key 'lisp-indent-function 'defun) (autoload 'evil-collection-swap-key "evil-collection" "Wrapper around `evil-collection-translate-key' for swapping keys.
STATES, KEYMAPS, and ARGS are passed to `evil-collection-translate-key'. ARGS
should consist of key swaps (e.g. \"a\" \"b\" is equivalent to \"a\" \"b\" \"b\"
\"a\" with `evil-collection-translate-key') and optionally keyword arguments for
`evil-collection-translate-key'.

(fn STATES KEYMAPS &rest ARGS)" nil t) (function-put 'evil-collection-swap-key 'lisp-indent-function 'defun) (autoload 'evil-collection-require "evil-collection" "Require the evil-collection-MODE file, but do not activate it.

MODE should be a symbol. This requires the evil-collection-MODE
feature without needing to manipulate `load-path'. NOERROR is
forwarded to `require'.

(fn MODE &optional NOERROR)" nil nil) (autoload 'evil-collection-init "evil-collection" "Register the Evil bindings for all modes in `evil-collection-mode-list'.

Alternatively, you may register select bindings manually, for
instance:

  (with-eval-after-load 'calendar
    (evil-collection-calendar-setup))

If MODES is specified (as either one mode or a list of modes), use those modes
instead of the modes in `evil-collection-mode-list'.

(fn &optional MODES)" t nil) (register-definition-prefixes "evil-collection" '("evil-collection-")) (provide 'evil-collection-autoloads)) "diminish" ((diminish-autoloads diminish) (autoload 'diminish "diminish" "Diminish mode-line display of minor mode MODE to TO-WHAT (default \"\").

Interactively, enter (with completion) the name of any minor mode, followed
on the next line by what you want it diminished to (default empty string).
The response to neither prompt should be quoted.  However, in Lisp code,
both args must be quoted, the first as a symbol, the second as a string,
as in (diminish 'jiggle-mode \" Jgl\").

The mode-line displays of minor modes usually begin with a space, so
the modes' names appear as separate words on the mode line.  However, if
you're having problems with a cramped mode line, you may choose to use single
letters for some modes, without leading spaces.  Capitalizing them works
best; if you then diminish some mode to \"X\" but have abbrev-mode enabled as
well, you'll get a display like \"AbbrevX\".  This function prepends a space
to TO-WHAT if it's > 1 char long & doesn't already begin with a space.

(fn MODE &optional TO-WHAT)" t nil) (autoload 'diminish-undo "diminish" "Restore mode-line display of diminished mode MODE to its minor-mode value.
Do nothing if the arg is a minor mode that hasn't been diminished.

Interactively, enter (with completion) the name of any diminished mode (a
mode that was formerly a minor mode on which you invoked \\[diminish]).
To restore all diminished modes to minor status, answer `diminished-modes'.
The response to the prompt shouldn't be quoted.  However, in Lisp code,
the arg must be quoted as a symbol, as in (diminish-undo 'diminished-modes).

(fn MODE)" t nil) (autoload 'diminished-modes "diminish" "Echo all active diminished or minor modes as if they were minor.
The display goes in the echo area; if it's too long even for that,
you can see the whole thing in the *Messages* buffer.
This doesn't change the status of any modes; it just lets you see
what diminished modes would be on the mode-line if they were still minor." t nil) (register-definition-prefixes "diminish" '("diminish")) (provide 'diminish-autoloads)) "which-key" ((which-key-autoloads which-key) (defvar which-key-mode nil "Non-nil if Which-Key mode is enabled.
See the `which-key-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `which-key-mode'.") (custom-autoload 'which-key-mode "which-key" nil) (autoload 'which-key-mode "which-key" "Toggle which-key-mode.

This is a minor mode.  If called interactively, toggle the
`Which-Key mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='which-key-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (autoload 'which-key-setup-side-window-right "which-key" "Apply suggested settings for side-window that opens on right." t nil) (autoload 'which-key-setup-side-window-right-bottom "which-key" "Apply suggested settings for side-window that opens on right
if there is space and the bottom otherwise." t nil) (autoload 'which-key-setup-side-window-bottom "which-key" "Apply suggested settings for side-window that opens on bottom." t nil) (autoload 'which-key-setup-minibuffer "which-key" "Apply suggested settings for minibuffer.
Do not use this setup if you use the paging commands. Instead use
`which-key-setup-side-window-bottom', which is nearly identical
but more functional." t nil) (autoload 'which-key-add-keymap-based-replacements "which-key" "Replace the description of KEY using REPLACEMENT in KEYMAP.
KEY should take a format suitable for use in `kbd'. REPLACEMENT
should be a cons cell of the form (STRING . COMMAND) for each
REPLACEMENT, where STRING is the replacement string and COMMAND
is a symbol corresponding to the intended command to be
replaced. COMMAND can be nil if the binding corresponds to a key
prefix. An example is

(which-key-add-keymap-based-replacements global-map
  \"C-x w\" '(\"Save as\" . write-file)).

For backwards compatibility, REPLACEMENT can also be a string,
but the above format is preferred, and the option to use a string
for REPLACEMENT will eventually be removed.

(fn KEYMAP KEY REPLACEMENT &rest MORE)" nil nil) (autoload 'which-key-add-key-based-replacements "which-key" "Replace the description of KEY-SEQUENCE with REPLACEMENT.
KEY-SEQUENCE is a string suitable for use in `kbd'. REPLACEMENT
may either be a string, as in

(which-key-add-key-based-replacements \"C-x 1\" \"maximize\")

a cons of two strings as in

(which-key-add-key-based-replacements \"C-x 8\"
                                        '(\"unicode\" . \"Unicode keys\"))

or a function that takes a (KEY . BINDING) cons and returns a
replacement.

In the second case, the second string is used to provide a longer
name for the keys under a prefix.

MORE allows you to specifcy additional KEY REPLACEMENT pairs.  All
replacements are added to `which-key-replacement-alist'.

(fn KEY-SEQUENCE REPLACEMENT &rest MORE)" nil nil) (autoload 'which-key-add-major-mode-key-based-replacements "which-key" "Functions like `which-key-add-key-based-replacements'.
The difference is that MODE specifies the `major-mode' that must
be active for KEY-SEQUENCE and REPLACEMENT (MORE contains
addition KEY-SEQUENCE REPLACEMENT pairs) to apply.

(fn MODE KEY-SEQUENCE REPLACEMENT &rest MORE)" nil nil) (autoload 'which-key-reload-key-sequence "which-key" "Simulate entering the key sequence KEY-SEQ.
KEY-SEQ should be a list of events as produced by
`listify-key-sequence'. If nil, KEY-SEQ defaults to
`which-key--current-key-list'. Any prefix arguments that were
used are reapplied to the new key sequence.

(fn &optional KEY-SEQ)" nil nil) (autoload 'which-key-show-standard-help "which-key" "Call the command in `which-key--prefix-help-cmd-backup'.
Usually this is `describe-prefix-bindings'.

(fn &optional _)" t nil) (autoload 'which-key-show-next-page-no-cycle "which-key" "Show next page of keys unless on the last page, in which case
call `which-key-show-standard-help'." t nil) (autoload 'which-key-show-previous-page-no-cycle "which-key" "Show previous page of keys unless on the first page, in which
case do nothing." t nil) (autoload 'which-key-show-next-page-cycle "which-key" "Show the next page of keys, cycling from end to beginning
after last page.

(fn &optional _)" t nil) (autoload 'which-key-show-previous-page-cycle "which-key" "Show the previous page of keys, cycling from beginning to end
after first page.

(fn &optional _)" t nil) (autoload 'which-key-show-top-level "which-key" "Show top-level bindings.

(fn &optional _)" t nil) (autoload 'which-key-show-major-mode "which-key" "Show top-level bindings in the map of the current major mode.

This function will also detect evil bindings made using
`evil-define-key' in this map. These bindings will depend on the
current evil state. 

(fn &optional ALL)" t nil) (autoload 'which-key-show-full-major-mode "which-key" "Show all bindings in the map of the current major mode.

This function will also detect evil bindings made using
`evil-define-key' in this map. These bindings will depend on the
current evil state. " t nil) (autoload 'which-key-dump-bindings "which-key" "Dump bindings from PREFIX into buffer named BUFFER-NAME.

PREFIX should be a string suitable for `kbd'.

(fn PREFIX BUFFER-NAME)" t nil) (autoload 'which-key-undo-key "which-key" "Undo last keypress and force which-key update.

(fn &optional _)" t nil) (autoload 'which-key-C-h-dispatch "which-key" "Dispatch C-h commands by looking up key in
`which-key-C-h-map'. This command is always accessible (from any
prefix) if `which-key-use-C-h-commands' is non nil." t nil) (autoload 'which-key-show-keymap "which-key" "Show the top-level bindings in KEYMAP using which-key.
KEYMAP is selected interactively from all available keymaps.

If NO-PAGING is non-nil, which-key will not intercept subsequent
keypresses for the paging functionality.

(fn KEYMAP &optional NO-PAGING)" t nil) (autoload 'which-key-show-full-keymap "which-key" "Show all bindings in KEYMAP using which-key.
KEYMAP is selected interactively from all available keymaps.

(fn KEYMAP)" t nil) (autoload 'which-key-show-minor-mode-keymap "which-key" "Show the top-level bindings in KEYMAP using which-key.
KEYMAP is selected interactively by mode in
`minor-mode-map-alist'.

(fn &optional ALL)" t nil) (autoload 'which-key-show-full-minor-mode-keymap "which-key" "Show all bindings in KEYMAP using which-key.
KEYMAP is selected interactively by mode in
`minor-mode-map-alist'." t nil) (register-definition-prefixes "which-key" '("evil-state" "which-key-")) (provide 'which-key-autoloads)) "general" ((\.dirs-local general-autoloads general) (autoload 'general-define-key "general" "The primary key definition function provided by general.el.

Define MAPS, optionally using DEFINER, in the keymap(s) corresponding to STATES
and KEYMAPS.

MAPS consists of paired keys (vectors or strings; also see
`general-implicit-kbd') and definitions (those mentioned in `define-key''s
docstring and general.el's \"extended\" definitions). All pairs (when not
ignored) will be recorded and can be later displayed with
`general-describe-keybindings'.

If DEFINER is specified, a custom key definer will be used to bind MAPS. See
general.el's documentation/README for more information.

Unlike with normal key definitions functions, the keymaps in KEYMAPS should be
quoted (this allows using the keymap name for other purposes, e.g. deferring
keybindings if the keymap symbol is not bound, optionally inferring the
corresponding major mode for a symbol by removing \"-map\" for :which-key,
easily storing the keymap name for use with `general-describe-keybindings',
etc.). Note that general.el provides other key definer macros that do not
require quoting keymaps.

STATES corresponds to the evil state(s) to bind the keys in. Non-evil users
should not set STATES. When STATES is non-nil, `evil-define-key*' will be
used (the evil auxiliary keymaps corresponding STATES and KEYMAPS will be used);
otherwise `define-key' will be used (unless DEFINER is specified). KEYMAPS
defaults to 'global. There is also 'local, which create buffer-local
keybindings for both evil and non-evil keybindings. There are other special,
user-alterable \"shorthand\" symbols for keymaps and states (see
`general-keymap-aliases' and `general-state-aliases').

Note that STATES and KEYMAPS can either be lists or single symbols. If any
keymap does not exist, those keybindings will be deferred until the keymap does
exist, so using `eval-after-load' is not necessary with this function.

PREFIX corresponds to a key to prefix keys in MAPS with and defaults to none. To
bind/unbind a key specified with PREFIX, \"\" can be specified as a key in
MAPS (e.g. ...:prefix \"SPC\" \"\" nil... will unbind space).

The keywords in this paragraph are only useful for evil users. If
NON-NORMAL-PREFIX is specified, this prefix will be used instead of PREFIX for
states in `general-non-normal-states' (e.g. the emacs and insert states). This
argument will only have an effect if one of these states is in STATES or if
corresponding global keymap (e.g. `evil-insert-state-map') is in KEYMAPS.
Alternatively, GLOBAL-PREFIX can be used with PREFIX and/or NON-NORMAL-PREFIX to
bind keys in all states under the specified prefix. Like with NON-NORMAL-PREFIX,
GLOBAL-PREFIX will prevent PREFIX from applying to `general-non-normal-states'.
INFIX can be used to append a string to all of the specified prefixes. This is
potentially useful when you are using GLOBAL-PREFIX and/or NON-NORMAL-PREFIX so
that you can sandwich keys in between all the prefixes and the specified keys in
MAPS. This may be particularly useful if you are using default prefixes in a
wrapper function/macro so that you can add to them without needing to re-specify
all of them. If none of the other prefix keyword arguments are specified, INFIX
will have no effect.

If PREFIX-COMMAND or PREFIX-MAP is specified, a prefix command and/or keymap
will be created. PREFIX-NAME can be additionally specified to set the keymap
menu name/prompt. If PREFIX-COMMAND is specified, `define-prefix-command' will
be used. Otherwise, only a prefix keymap will be created. Previously created
prefix commands/keymaps will never be redefined/cleared. All prefixes (including
the INFIX key, if specified) will then be bound to PREFIX-COMMAND or PREFIX-MAP.
If the user did not specify any PREFIX or manually specify any KEYMAPS, general
will bind all MAPS in the prefix keymap corresponding to either PREFIX-MAP or
PREFIX-COMMAND instead of in the default keymap.

PREDICATE corresponds to a predicate to check to determine whether a definition
should be active (e.g. \":predicate '(eobp)\"). Definitions created with a
predicate will only be active when the predicate is true. When the predicate is
false, key lookup will continue to search for a match in lower-precedence
keymaps.

In addition to the normal definitions supported by `define-key', general.el also
provides \"extended\" definitions, which are plists containing the normal
definition as well as other keywords. For example, PREDICATE can be specified
globally or locally in an extended definition. New global (~general-define-key~)
and local (extended definition) keywords can be added by the user. See
`general-extended-def-keywords' and general.el's documentation/README for more
information.

PACKAGE is the global version of the extended definition keyword that specifies
the package a keymap is defined in (used for \"autoloading\" keymaps)

PROPERTIES, REPEAT, and JUMP are the global versions of the extended definition
keywords used for adding evil command properties to commands.

MAJOR-MODES, WK-MATCH-KEYS, WK-MATCH-BINDINGS, and WK-FULL-KEYS are the
corresponding global versions of which-key extended definition keywords. They
will only have an effect for extended definitions that specify :which-key or
:wk. See the section on extended definitions in the general.el
documentation/README for more information.

LISPY-PLIST and WORF-PLIST are the global versions of extended definition
keywords that are used for each corresponding custom DEFINER.

(fn &rest MAPS &key DEFINER (STATES general-default-states) (KEYMAPS general-default-keymaps KEYMAPS-SPECIFIED-P) (PREFIX general-default-prefix) (NON-NORMAL-PREFIX general-default-non-normal-prefix) (GLOBAL-PREFIX general-default-global-prefix) INFIX PREFIX-COMMAND PREFIX-MAP PREFIX-NAME PREDICATE PACKAGE PROPERTIES REPEAT JUMP MAJOR-MODES (WK-MATCH-KEYS t) (WK-MATCH-BINDING t) (WK-FULL-KEYS t) LISPY-PLIST WORF-PLIST &allow-other-keys)" nil nil) (autoload 'general-emacs-define-key "general" "A wrapper for `general-define-key' that is similar to `define-key'.
It has a positional argument for KEYMAPS (that will not be overridden by a later
:keymaps argument). Besides this, it acts the same as `general-define-key', and
ARGS can contain keyword arguments in addition to keybindings. This can
basically act as a drop-in replacement for `define-key', and unlike with
`general-define-key', KEYMAPS does not need to be quoted.

(fn KEYMAPS &rest ARGS)" nil t) (function-put 'general-emacs-define-key 'lisp-indent-function '1) (autoload 'general-evil-define-key "general" "A wrapper for `general-define-key' that is similar to `evil-define-key'.
It has positional arguments for STATES and KEYMAPS (that will not be overridden
by a later :keymaps or :states argument). Besides this, it acts the same as
`general-define-key', and ARGS can contain keyword arguments in addition to
keybindings. This can basically act as a drop-in replacement for
`evil-define-key', and unlike with `general-define-key', KEYMAPS does not need
to be quoted.

(fn STATES KEYMAPS &rest ARGS)" nil t) (function-put 'general-evil-define-key 'lisp-indent-function '2) (autoload 'general-def "general" "General definer that takes a variable number of positional arguments in ARGS.
This macro will act as `general-define-key', `general-emacs-define-key', or
`general-evil-define-key' based on how many of the initial arguments do not
correspond to keybindings. All quoted and non-quoted lists and symbols before
the first string, vector, or keyword are considered to be positional arguments.
This means that you cannot use a function or variable for a key that starts
immediately after the positional arguments. If you need to do this, you should
use one of the definers that `general-def' dispatches to or explicitly separate
the positional arguments from the maps with a bogus keyword pair like
\":start-maps t\"

(fn &rest ARGS)" nil t) (function-put 'general-def 'lisp-indent-function 'defun) (autoload 'general-create-definer "general" "A helper macro to create wrappers for `general-def'.
This can be used to create key definers that will use a certain keymap, evil
state, prefix key, etc. by default. NAME is the wrapper name and DEFAULTS are
the default arguments. WRAPPING can also be optionally specified to use a
different definer than `general-def'. It should not be quoted.

(fn NAME &rest DEFAULTS &key WRAPPING &allow-other-keys)" nil t) (function-put 'general-create-definer 'lisp-indent-function 'defun) (autoload 'general-defs "general" "A wrapper that splits into multiple `general-def's.
Each consecutive grouping of positional argument followed by keyword/argument
pairs (having only one or the other is fine) marks the start of a new section.
Each section corresponds to one use of `general-def'. This means that settings
only apply to the keybindings that directly follow.

Since positional arguments can appear at any point, unqouted symbols are always
considered to be positional arguments (e.g. a keymap). This means that variables
can never be used for keys with `general-defs'. Variables can still be used for
definitions or as arguments to keywords.

(fn &rest ARGS)" nil t) (function-put 'general-defs 'lisp-indent-function 'defun) (autoload 'general-unbind "general" "A wrapper for `general-def' to unbind multiple keys simultaneously.
Insert after all keys in ARGS before passing ARGS to `general-def.' \":with
 #'func\" can optionally specified to use a custom function instead (e.g.
 `ignore').

(fn &rest ARGS)" nil t) (function-put 'general-unbind 'lisp-indent-function 'defun) (autoload 'general-describe-keybindings "general" "Show all keys that have been bound with general in an org buffer.
Any local keybindings will be shown first followed by global keybindings.
With a non-nil prefix ARG only show bindings in active maps.

(fn &optional ARG)" t nil) (autoload 'general-key "general" "Act as KEY's definition in the current context.
This uses an extended menu item's capability of dynamically computing a
definition. It is recommended over `general-simulate-key' wherever possible. See
the docstring of `general-simulate-key' and the readme for information about the
benefits and downsides of `general-key'.

KEY should be a string given in `kbd' notation and should correspond to a single
definition (as opposed to a sequence of commands). When STATE is specified, look
up KEY with STATE as the current evil state. When specified, DOCSTRING will be
the menu item's name/description.

Let can be used to bind variables around key lookup. For example:
(general-key \"some key\"
  :let ((some-var some-val)))

SETUP and TEARDOWN can be used to run certain functions before and after key
lookup. For example, something similar to using :state 'emacs would be:
(general-key \"some key\"
  :setup (evil-local-mode -1)
  :teardown (evil-local-mode))

ACCEPT-DEFAULT, NO-REMAP, and POSITION are passed to `key-binding'.

(fn KEY &key STATE DOCSTRING LET SETUP TEARDOWN ACCEPT-DEFAULT NO-REMAP POSITION)" nil t) (function-put 'general-key 'lisp-indent-function '1) (autoload 'general-simulate-keys "general" "Deprecated. Please use `general-simulate-key' instead.

(fn KEYS &optional STATE KEYMAP (LOOKUP t) DOCSTRING NAME)" nil t) (autoload 'general-simulate-key "general" "Create and return a command that simulates KEYS in STATE and KEYMAP.

`general-key' should be prefered over this whenever possible as it is simpler
and has saner functionality in many cases because it does not rely on
`unread-command-events' (e.g. \"C-h k\" will show the docstring of the command
to be simulated ; see the readme for more information). The main downsides of
`general-key' are that it cannot simulate a command followed by keys or
subsequent commands, and which-key does not currently work well with it when
simulating a prefix key/incomplete key sequence.

KEYS should be a string given in `kbd' notation. It can also be a list of a
single command followed by a string of the key(s) to simulate after calling that
command. STATE should only be specified by evil users and should be a quoted
evil state. KEYMAP should not be quoted. Both STATE and KEYMAP aliases are
supported (but they have to be set when the macro is expanded). When neither
STATE or KEYMAP are specified, the key(s) will be simulated in the current
context.

If NAME is specified, it will replace the automatically generated function name.
NAME should not be quoted. If DOCSTRING is specified, it will replace the
automatically generated docstring.

Normally the generated function will look up KEY in the correct context to try
to match a command. To prevent this lookup, LOOKUP can be specified as nil.
Generally, you will want to keep LOOKUP non-nil because this will allow checking
the evil repeat property of matched commands to determine whether or not they
should be recorded. See the docstring for `general--simulate-keys' for more
information about LOOKUP.

When a WHICH-KEY description is specified, it will replace the command name in
the which-key popup.

When a command name is specified and that command has been remapped (i.e. [remap
command] is currently bound), the remapped version will be used instead of the
original command unless REMAP is specified as nil (it is true by default).

The advantages of this over a keyboard macro are as follows:
- Prefix arguments are supported
- The user can control the context in which the keys are simulated
- The user can simulate both a named command and keys
- The user can simulate an incomplete key sequence (e.g. for a keymap)

(fn KEYS &key STATE KEYMAP NAME DOCSTRING (LOOKUP t) WHICH-KEY (REMAP t))" nil t) (function-put 'general-simulate-key 'lisp-indent-function 'defun) (autoload 'general-key-dispatch "general" "Create and return a command that runs FALLBACK-COMMAND or a command in MAPS.
MAPS consists of <key> <command> pairs. If a key in MAPS is matched, the
corresponding command will be run. Otherwise FALLBACK-COMMAND will be run with
the unmatched keys. So, for example, if \"ab\" was pressed, and \"ab\" is not
one of the key sequences from MAPS, the FALLBACK-COMMAND will be run followed by
the simulated keypresses of \"ab\". Prefix arguments will still work regardless
of which command is run. This is useful for binding under non-prefix keys. For
example, this can be used to redefine a sequence like \"cw\" or \"cow\" in evil
but still have \"c\" work as `evil-change'. If TIMEOUT is specified,
FALLBACK-COMMAND will also be run in the case that the user does not press the
next key within the TIMEOUT (e.g. 0.5).

NAME and DOCSTRING are optional keyword arguments. They can be used to replace
the automatically generated name and docstring for the created function. By
default, `cl-gensym' is used to prevent name clashes (e.g. allows the user to
create multiple different commands using `self-insert-command' as the
FALLBACK-COMMAND without explicitly specifying NAME to manually prevent
clashes).

When INHERIT-KEYMAP is specified, all the keybindings from that keymap will be
inherited in MAPS.

When a WHICH-KEY description is specified, it will replace the command name in
the which-key popup.

When command to be executed has been remapped (i.e. [remap command] is currently
bound), the remapped version will be used instead of the original command unless
REMAP is specified as nil (it is true by default).

(fn FALLBACK-COMMAND &rest MAPS &key TIMEOUT INHERIT-KEYMAP NAME DOCSTRING WHICH-KEY (REMAP t) &allow-other-keys)" nil t) (function-put 'general-key-dispatch 'lisp-indent-function '1) (autoload 'general-predicate-dispatch "general" "

(fn FALLBACK-DEF &rest DEFS &key DOCSTRING &allow-other-keys)" nil t) (function-put 'general-predicate-dispatch 'lisp-indent-function '1) (autoload 'general-translate-key "general" "Translate keys in the keymap(s) corresponding to STATES and KEYMAPS.
STATES should be the name of an evil state, a list of states, or nil. KEYMAPS
should be a symbol corresponding to the keymap to make the translations in or a
list of keymap names. Keymap and state aliases are supported (as well as 'local
and 'global for KEYMAPS).

MAPS corresponds to a list of translations (key replacement pairs). For example,
specifying \"a\" \"b\" will bind \"a\" to \"b\"'s definition in the keymap.
Specifying nil as a replacement will unbind a key.

If DESTRUCTIVE is non-nil, the keymap will be destructively altered without
creating a backup. If DESTRUCTIVE is nil, store a backup of the keymap on the
initial invocation, and for future invocations always look up keys in the
original/backup keymap. On the other hand, if DESTRUCTIVE is non-nil, calling
this function multiple times with \"a\" \"b\" \"b\" \"a\", for example, would
continue to swap and unswap the definitions of these keys. This means that when
DESTRUCTIVE is non-nil, all related swaps/cycles should be done in the same
invocation.

If both MAPS and DESCTRUCTIVE are nil, only create the backup keymap.

(fn STATES KEYMAPS &rest MAPS &key DESTRUCTIVE &allow-other-keys)" nil nil) (function-put 'general-translate-key 'lisp-indent-function 'defun) (autoload 'general-swap-key "general" "Wrapper around `general-translate-key' for swapping keys.
STATES, KEYMAPS, and ARGS are passed to `general-translate-key'. ARGS should
consist of key swaps (e.g. \"a\" \"b\" is equivalent to \"a\" \"b\" \"b\" \"a\"
with `general-translate-key') and optionally keyword arguments for
`general-translate-key'.

(fn STATES KEYMAPS &rest ARGS)" nil t) (function-put 'general-swap-key 'lisp-indent-function 'defun) (autoload 'general-auto-unbind-keys "general" "Advise `define-key' to automatically unbind keys when necessary.
This will prevent errors when a sub-sequence of a key is already bound (e.g. the
user attempts to bind \"SPC a\" when \"SPC\" is bound, resulting in a \"Key
sequnce starts with non-prefix key\" error). When UNDO is non-nil, remove
advice.

(fn &optional UNDO)" nil nil) (autoload 'general-add-hook "general" "A drop-in replacement for `add-hook'.
Unlike `add-hook', HOOKS and FUNCTIONS can be single items or lists. APPEND and
LOCAL are passed directly to `add-hook'. When TRANSIENT is non-nil, each
function will remove itself from the hook it is in after it is run once. If
TRANSIENT is a function, call it on the return value in order to determine
whether to remove a function from the hook. For example, if TRANSIENT is
#'identity, remove each function only if it returns non-nil. TRANSIENT could
alternatively check something external and ignore the function's return value.

(fn HOOKS FUNCTIONS &optional APPEND LOCAL TRANSIENT)" nil nil) (autoload 'general-remove-hook "general" "A drop-in replacement for `remove-hook'.
Unlike `remove-hook', HOOKS and FUNCTIONS can be single items or lists. LOCAL is
passed directly to `remove-hook'.

(fn HOOKS FUNCTIONS &optional LOCAL)" nil nil) (autoload 'general-advice-add "general" "A drop-in replacement for `advice-add'.
SYMBOLS, WHERE, FUNCTIONS, and PROPS correspond to the arguments for
`advice-add'. Unlike `advice-add', SYMBOLS and FUNCTIONS can be single items or
lists. When TRANSIENT is non-nil, each function will remove itself as advice
after it is run once. If TRANSIENT is a function, call it on the return value in
order to determine whether to remove a function as advice. For example, if
TRANSIENT is #'identity, remove each function only if it returns non-nil.
TRANSIENT could alternatively check something external and ignore the function's
return value.

(fn SYMBOLS WHERE FUNCTIONS &optional PROPS TRANSIENT)" nil nil) (autoload 'general-add-advice "general") (autoload 'general-advice-remove "general" "A drop-in replacement for `advice-remove'.
Unlike `advice-remove', SYMBOLS and FUNCTIONS can be single items or lists.

(fn SYMBOLS FUNCTIONS)" nil nil) (autoload 'general-remove-advice "general") (autoload 'general-evil-setup "general" "Set up some basic equivalents for vim mapping functions.
This creates global key definition functions for the evil states.
Specifying SHORT-NAMES as non-nil will create non-prefixed function
aliases such as `nmap' for `general-nmap'.

(fn &optional SHORT-NAMES _)" nil nil) (register-definition-prefixes "general" '("general-")) (provide 'general-autoloads)) "spacegray-theme" ((spacegray-theme-autoloads spacegray-theme) (when (and (boundp 'custom-theme-load-path) load-file-name) (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name)))) (register-definition-prefixes "spacegray-theme" '("spacegray")) (provide 'spacegray-theme-autoloads)) "doom-themes" ((doom-laserwave-theme doom-moonlight-theme doom-peacock-theme doom-oceanic-next-theme doom-monokai-machine-theme doom-zenburn-theme doom-one-theme doom-ephemeral-theme doom-themes-ext-neotree doom-ir-black-theme doom-vibrant-theme doom-plain-theme doom-city-lights-theme doom-opera-theme doom-manegarm-theme doom-miramare-theme doom-shades-of-purple-theme doom-monokai-spectrum-theme doom-monokai-classic-theme doom-one-light-theme doom-flatwhite-theme doom-sourcerer-theme doom-monokai-octagon-theme doom-solarized-light-theme doom-themes-autoloads doom-dracula-theme doom-solarized-dark-theme doom-themes doom-snazzy-theme doom-ayu-mirage-theme doom-spacegrey-theme doom-monokai-pro-theme doom-wilmersdorf-theme doom-homage-white-theme doom-dark+-theme doom-Iosvkem-theme doom-gruvbox-light-theme doom-opera-light-theme doom-tomorrow-day-theme doom-tomorrow-night-theme doom-themes-ext-org doom-acario-dark-theme doom-nord-theme doom-outrun-electric-theme doom-gruvbox-theme doom-themes-ext-visual-bell doom-acario-light-theme doom-fairy-floss-theme doom-rouge-theme doom-themes-ext-treemacs doom-plain-dark-theme doom-1337-theme doom-molokai-theme doom-solarized-dark-high-contrast-theme doom-material-theme doom-old-hope-theme doom-henna-theme doom-xcode-theme doom-nord-light-theme doom-badger-theme doom-horizon-theme doom-palenight-theme doom-monokai-ristretto-theme doom-themes-base doom-homage-black-theme doom-challenger-deep-theme doom-ayu-light-theme doom-nova-theme) (register-definition-prefixes "doom-1337-theme" '("doom-1337")) (register-definition-prefixes "doom-Iosvkem-theme" '("doom-Iosvkem")) (register-definition-prefixes "doom-acario-dark-theme" '("doom-acario-dark")) (register-definition-prefixes "doom-acario-light-theme" '("doom-acario-light")) (register-definition-prefixes "doom-ayu-light-theme" '("doom-ayu-light")) (register-definition-prefixes "doom-ayu-mirage-theme" '("doom-ayu-mirage")) (register-definition-prefixes "doom-badger-theme" '("doom-badger")) (register-definition-prefixes "doom-challenger-deep-theme" '("doom-challenger-deep")) (register-definition-prefixes "doom-city-lights-theme" '("doom-city-lights")) (register-definition-prefixes "doom-dark+-theme" '("doom-dark+")) (register-definition-prefixes "doom-dracula-theme" '("doom-dracula")) (register-definition-prefixes "doom-ephemeral-theme" '("doom-ephemeral")) (register-definition-prefixes "doom-fairy-floss-theme" '("doom-fairy-floss")) (register-definition-prefixes "doom-flatwhite-theme" '("doom-f")) (register-definition-prefixes "doom-gruvbox-light-theme" '("doom-gruvbox-light")) (register-definition-prefixes "doom-gruvbox-theme" '("doom-gruvbox")) (register-definition-prefixes "doom-henna-theme" '("doom-henna")) (register-definition-prefixes "doom-homage-black-theme" '("doom-homage-black")) (register-definition-prefixes "doom-homage-white-theme" '("doom-homage-white")) (register-definition-prefixes "doom-horizon-theme" '("doom-horizon")) (register-definition-prefixes "doom-ir-black-theme" '("doom-ir-black")) (register-definition-prefixes "doom-laserwave-theme" '("doom-laserwave")) (register-definition-prefixes "doom-manegarm-theme" '("doom-manegarm")) (register-definition-prefixes "doom-material-theme" '("doom-material")) (register-definition-prefixes "doom-miramare-theme" '("doom-miramare")) (register-definition-prefixes "doom-molokai-theme" '("doom-molokai")) (register-definition-prefixes "doom-monokai-classic-theme" '("doom-monokai-classic")) (register-definition-prefixes "doom-monokai-machine-theme" '("doom-monokai-machine")) (register-definition-prefixes "doom-monokai-octagon-theme" '("doom-monokai-octagon")) (register-definition-prefixes "doom-monokai-pro-theme" '("doom-monokai-pro")) (register-definition-prefixes "doom-monokai-ristretto-theme" '("doom-monokai-ristretto")) (register-definition-prefixes "doom-monokai-spectrum-theme" '("doom-monokai-spectrum")) (register-definition-prefixes "doom-moonlight-theme" '("doom-moonlight")) (register-definition-prefixes "doom-nord-light-theme" '("doom-nord-light")) (register-definition-prefixes "doom-nord-theme" '("doom-nord")) (register-definition-prefixes "doom-nova-theme" '("doom-nova")) (register-definition-prefixes "doom-oceanic-next-theme" '("doom-oceanic-next")) (register-definition-prefixes "doom-old-hope-theme" '("doom-old-hope")) (register-definition-prefixes "doom-one-light-theme" '("doom-one-light")) (register-definition-prefixes "doom-one-theme" '("doom-one")) (register-definition-prefixes "doom-opera-light-theme" '("doom-opera-light")) (register-definition-prefixes "doom-opera-theme" '("doom-opera")) (register-definition-prefixes "doom-outrun-electric-theme" '("doom-outrun-electric")) (register-definition-prefixes "doom-palenight-theme" '("doom-palenight")) (register-definition-prefixes "doom-peacock-theme" '("doom-peacock")) (register-definition-prefixes "doom-plain-dark-theme" '("doom-plain-")) (register-definition-prefixes "doom-plain-theme" '("doom-plain")) (register-definition-prefixes "doom-rouge-theme" '("doom-rouge")) (register-definition-prefixes "doom-shades-of-purple-theme" '("doom-shades-of-purple")) (register-definition-prefixes "doom-snazzy-theme" '("doom-snazzy")) (register-definition-prefixes "doom-solarized-dark-high-contrast-theme" '("doom-solarized-dark-high-contrast")) (register-definition-prefixes "doom-solarized-dark-theme" '("doom-solarized-dark")) (register-definition-prefixes "doom-solarized-light-theme" '("doom-solarized-light")) (register-definition-prefixes "doom-sourcerer-theme" '("doom-sourcerer")) (register-definition-prefixes "doom-spacegrey-theme" '("doom-spacegrey")) (autoload 'doom-name-to-rgb "doom-themes" "Retrieves the hexidecimal string repesented the named COLOR (e.g. \"red\")
for FRAME (defaults to the current frame).

(fn COLOR)" nil nil) (autoload 'doom-blend "doom-themes" "Blend two colors (hexidecimal strings) together by a coefficient ALPHA (a
float between 0 and 1)

(fn COLOR1 COLOR2 ALPHA)" nil nil) (autoload 'doom-darken "doom-themes" "Darken a COLOR (a hexidecimal string) by a coefficient ALPHA (a float between
0 and 1).

(fn COLOR ALPHA)" nil nil) (autoload 'doom-lighten "doom-themes" "Brighten a COLOR (a hexidecimal string) by a coefficient ALPHA (a float
between 0 and 1).

(fn COLOR ALPHA)" nil nil) (autoload 'doom-color "doom-themes" "Retrieve a specific color named NAME (a symbol) from the current theme.

(fn NAME &optional TYPE)" nil nil) (autoload 'doom-ref "doom-themes" "TODO

(fn FACE PROP &optional CLASS)" nil nil) (autoload 'doom-themes-set-faces "doom-themes" "Customize THEME (a symbol) with FACES.

If THEME is nil, it applies to all themes you load. FACES is a list of Doom
theme face specs. These is a simplified spec. For example:

  (doom-themes-set-faces 'user
    '(default :background red :foreground blue)
    '(doom-modeline-bar :background (if -modeline-bright modeline-bg highlight))
    '(doom-modeline-buffer-file :inherit 'mode-line-buffer-id :weight 'bold)
    '(doom-modeline-buffer-path :inherit 'mode-line-emphasis :weight 'bold)
    '(doom-modeline-buffer-project-root :foreground green :weight 'bold))

(fn THEME &rest FACES)" nil nil) (function-put 'doom-themes-set-faces 'lisp-indent-function 'defun) (when (and (boundp 'custom-theme-load-path) load-file-name) (let* ((base (file-name-directory load-file-name)) (dir (expand-file-name "themes/" base))) (add-to-list 'custom-theme-load-path (or (and (file-directory-p dir) dir) base)))) (register-definition-prefixes "doom-themes" '("def-doom-theme" "doom-")) (register-definition-prefixes "doom-themes-base" '("doom-themes-base-")) (autoload 'doom-themes-neotree-config "doom-themes-ext-neotree" "Install doom-themes' neotree configuration.

Includes an Atom-esque icon theme and highlighting based on filetype." nil nil) (register-definition-prefixes "doom-themes-ext-neotree" '("doom-")) (autoload 'doom-themes-org-config "doom-themes-ext-org" "Load `doom-themes-ext-org'." nil nil) (register-definition-prefixes "doom-themes-ext-org" '("doom-themes-")) (autoload 'doom-themes-treemacs-config "doom-themes-ext-treemacs" "Install doom-themes' treemacs configuration.

Includes an Atom-esque icon theme and highlighting based on filetype." nil nil) (register-definition-prefixes "doom-themes-ext-treemacs" '("doom-themes-")) (autoload 'doom-themes-visual-bell-fn "doom-themes-ext-visual-bell" "Blink the mode-line red briefly. Set `ring-bell-function' to this to use it." nil nil) (autoload 'doom-themes-visual-bell-config "doom-themes-ext-visual-bell" "Enable flashing the mode-line on error." nil nil) (register-definition-prefixes "doom-tomorrow-day-theme" '("doom-tomorrow-day")) (register-definition-prefixes "doom-tomorrow-night-theme" '("doom-tomorrow-night")) (register-definition-prefixes "doom-vibrant-theme" '("doom-vibrant")) (register-definition-prefixes "doom-wilmersdorf-theme" '("doom-wilmersdorf")) (register-definition-prefixes "doom-xcode-theme" '("doom-xcode")) (register-definition-prefixes "doom-zenburn-theme" '("doom-zenburn")) (provide 'doom-themes-autoloads)) "dash" ((dash-autoloads dash) (autoload 'dash-fontify-mode "dash" "Toggle fontification of Dash special variables.

This is a minor mode.  If called interactively, toggle the
`Dash-Fontify mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `dash-fontify-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

Dash-Fontify mode is a buffer-local minor mode intended for Emacs
Lisp buffers.  Enabling it causes the special variables bound in
anaphoric Dash macros to be fontified.  These anaphoras include
`it', `it-index', `acc', and `other'.  In older Emacs versions
which do not dynamically detect macros, Dash-Fontify mode
additionally fontifies Dash macro calls.

See also `dash-fontify-mode-lighter' and
`global-dash-fontify-mode'.

(fn &optional ARG)" t nil) (put 'global-dash-fontify-mode 'globalized-minor-mode t) (defvar global-dash-fontify-mode nil "Non-nil if Global Dash-Fontify mode is enabled.
See the `global-dash-fontify-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-dash-fontify-mode'.") (custom-autoload 'global-dash-fontify-mode "dash" nil) (autoload 'global-dash-fontify-mode "dash" "Toggle Dash-Fontify mode in all buffers.
With prefix ARG, enable Global Dash-Fontify mode if ARG is positive;
otherwise, disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Dash-Fontify mode is enabled in all buffers where
`dash--turn-on-fontify-mode' would do it.

See `dash-fontify-mode' for more information on Dash-Fontify mode.

(fn &optional ARG)" t nil) (register-definition-prefixes "dash" '("!cdr" "!cons" "--" "->" "-a" "-butlast" "-c" "-d" "-e" "-f" "-gr" "-i" "-keep" "-l" "-m" "-non" "-only-some" "-p" "-r" "-s" "-t" "-u" "-value-to-list" "-when-let" "-zip" "dash-")) (provide 'dash-autoloads)) "ht" ((ht ht-autoloads) (register-definition-prefixes "ht" 'nil) (provide 'ht-autoloads)) "emojify" ((emojify emojify-autoloads) (autoload 'emojify-set-emoji-styles "emojify" "Set the type of emojis that should be displayed.

STYLES is the styles emoji styles that should be used, see `emojify-emoji-styles'

(fn STYLES)" nil nil) (autoload 'emojify-mode "emojify" "Emojify mode

This is a minor mode.  If called interactively, toggle the
`Emojify mode' mode.  If the prefix argument is positive, enable
the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `emojify-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (put 'global-emojify-mode 'globalized-minor-mode t) (defvar global-emojify-mode nil "Non-nil if Global Emojify mode is enabled.
See the `global-emojify-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-emojify-mode'.") (custom-autoload 'global-emojify-mode "emojify" nil) (autoload 'global-emojify-mode "emojify" "Toggle Emojify mode in all buffers.
With prefix ARG, enable Global Emojify mode if ARG is positive;
otherwise, disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Emojify mode is enabled in all buffers where `emojify-mode' would do
it.

See `emojify-mode' for more information on Emojify mode.

(fn &optional ARG)" t nil) (autoload 'emojify-mode-line-mode "emojify" "Emojify mode line

This is a minor mode.  If called interactively, toggle the
`Emojify-Mode-Line mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `emojify-mode-line-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (put 'global-emojify-mode-line-mode 'globalized-minor-mode t) (defvar global-emojify-mode-line-mode nil "Non-nil if Global Emojify-Mode-Line mode is enabled.
See the `global-emojify-mode-line-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-emojify-mode-line-mode'.") (custom-autoload 'global-emojify-mode-line-mode "emojify" nil) (autoload 'global-emojify-mode-line-mode "emojify" "Toggle Emojify-Mode-Line mode in all buffers.
With prefix ARG, enable Global Emojify-Mode-Line mode if ARG is
positive; otherwise, disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Emojify-Mode-Line mode is enabled in all buffers where
`emojify-mode-line-mode' would do it.

See `emojify-mode-line-mode' for more information on Emojify-Mode-Line
mode.

(fn &optional ARG)" t nil) (autoload 'emojify-apropos-emoji "emojify" "Show Emojis that match PATTERN.

(fn PATTERN)" t nil) (autoload 'emojify-insert-emoji "emojify" "Interactively prompt for Emojis and insert them in the current buffer.

This respects the `emojify-emoji-styles' variable." t nil) (register-definition-prefixes "emojify" '("emojify-")) (provide 'emojify-autoloads)) "minions" ((minions minions-autoloads) (defvar minions-mode nil "Non-nil if Minions mode is enabled.
See the `minions-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `minions-mode'.") (custom-autoload 'minions-mode "minions" nil) (autoload 'minions-mode "minions" "Display a minor-mode menu in the mode line.

This is a minor mode.  If called interactively, toggle the
`Minions mode' mode.  If the prefix argument is positive, enable
the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='minions-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

This replaces the likely incomplete and possibly cut off list of
minor-modes that is usually displayed directly in the mode line.

(fn &optional ARG)" t nil) (register-definition-prefixes "minions" '("minions-")) (provide 'minions-autoloads)) "all-the-icons" ((all-the-icons all-the-icons-faces all-the-icons-autoloads) (autoload 'all-the-icons-icon-for-dir "all-the-icons" "Get the formatted icon for DIR.
ARG-OVERRIDES should be a plist containining `:height',
`:v-adjust' or `:face' properties like in the normal icon
inserting functions.

Note: You want chevron, please use `all-the-icons-icon-for-dir-with-chevron'.

(fn DIR &rest ARG-OVERRIDES)" nil nil) (autoload 'all-the-icons-icon-for-file "all-the-icons" "Get the formatted icon for FILE.
ARG-OVERRIDES should be a plist containining `:height',
`:v-adjust' or `:face' properties like in the normal icon
inserting functions.

(fn FILE &rest ARG-OVERRIDES)" nil nil) (autoload 'all-the-icons-icon-for-mode "all-the-icons" "Get the formatted icon for MODE.
ARG-OVERRIDES should be a plist containining `:height',
`:v-adjust' or `:face' properties like in the normal icon
inserting functions.

(fn MODE &rest ARG-OVERRIDES)" nil nil) (autoload 'all-the-icons-icon-for-url "all-the-icons" "Get the formatted icon for URL.
If an icon for URL isn't found in `all-the-icons-url-alist', a globe is used.
ARG-OVERRIDES should be a plist containining `:height',
`:v-adjust' or `:face' properties like in the normal icon
inserting functions.

(fn URL &rest ARG-OVERRIDES)" nil nil) (autoload 'all-the-icons-install-fonts "all-the-icons" "Helper function to download and install the latests fonts based on OS.
When PFX is non-nil, ignore the prompt and just install

(fn &optional PFX)" t nil) (autoload 'all-the-icons-insert "all-the-icons" "Interactive icon insertion function.
When Prefix ARG is non-nil, insert the propertized icon.
When FAMILY is non-nil, limit the candidates to the icon set matching it.

(fn &optional ARG FAMILY)" t nil) (register-definition-prefixes "all-the-icons" '("all-the-icons-")) (provide 'all-the-icons-autoloads)) "s" ((s s-autoloads) (register-definition-prefixes "s" '("s-")) (provide 's-autoloads)) "f" ((f-autoloads f) (register-definition-prefixes "f" '("f-")) (provide 'f-autoloads)) "shrink-path" ((shrink-path-autoloads shrink-path) (register-definition-prefixes "shrink-path" '("shrink-path-")) (provide 'shrink-path-autoloads)) "doom-modeline" ((doom-modeline doom-modeline-env doom-modeline-core doom-modeline-autoloads doom-modeline-segments) (autoload 'doom-modeline-init "doom-modeline" "Initialize doom mode-line." nil nil) (autoload 'doom-modeline-set-main-modeline "doom-modeline" "Set main mode-line.
If DEFAULT is non-nil, set the default mode-line for all buffers.

(fn &optional DEFAULT)" nil nil) (autoload 'doom-modeline-set-minimal-modeline "doom-modeline" "Set minimal mode-line." nil nil) (autoload 'doom-modeline-set-special-modeline "doom-modeline" "Set special mode-line." nil nil) (autoload 'doom-modeline-set-project-modeline "doom-modeline" "Set project mode-line." nil nil) (autoload 'doom-modeline-set-dashboard-modeline "doom-modeline" "Set dashboard mode-line." nil nil) (autoload 'doom-modeline-set-vcs-modeline "doom-modeline" "Set vcs mode-line." nil nil) (autoload 'doom-modeline-set-info-modeline "doom-modeline" "Set Info mode-line." nil nil) (autoload 'doom-modeline-set-package-modeline "doom-modeline" "Set package mode-line." nil nil) (autoload 'doom-modeline-set-media-modeline "doom-modeline" "Set media mode-line." nil nil) (autoload 'doom-modeline-set-message-modeline "doom-modeline" "Set message mode-line." nil nil) (autoload 'doom-modeline-set-pdf-modeline "doom-modeline" "Set pdf mode-line." nil nil) (autoload 'doom-modeline-set-org-src-modeline "doom-modeline" "Set org-src mode-line." nil nil) (autoload 'doom-modeline-set-helm-modeline "doom-modeline" "Set helm mode-line.

(fn &rest _)" nil nil) (autoload 'doom-modeline-set-timemachine-modeline "doom-modeline" "Set timemachine mode-line." nil nil) (defvar doom-modeline-mode nil "Non-nil if Doom-Modeline mode is enabled.
See the `doom-modeline-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `doom-modeline-mode'.") (custom-autoload 'doom-modeline-mode "doom-modeline" nil) (autoload 'doom-modeline-mode "doom-modeline" "Toggle doom-modeline on or off.

This is a minor mode.  If called interactively, toggle the
`Doom-Modeline mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='doom-modeline-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (register-definition-prefixes "doom-modeline" '("doom-modeline-mode-map")) (register-definition-prefixes "doom-modeline-core" '("doom-modeline")) (autoload 'doom-modeline-env-setup-python "doom-modeline-env") (autoload 'doom-modeline-env-setup-ruby "doom-modeline-env") (autoload 'doom-modeline-env-setup-perl "doom-modeline-env") (autoload 'doom-modeline-env-setup-go "doom-modeline-env") (autoload 'doom-modeline-env-setup-elixir "doom-modeline-env") (autoload 'doom-modeline-env-setup-rust "doom-modeline-env") (register-definition-prefixes "doom-modeline-env" '("doom-modeline-")) (register-definition-prefixes "doom-modeline-segments" '("doom-modeline-")) (provide 'doom-modeline-autoloads)) "perspective" ((perspective perspective-autoloads) (defvar persp-mode nil "Non-nil if Persp mode is enabled.
See the `persp-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `persp-mode'.") (custom-autoload 'persp-mode "perspective" nil) (autoload 'persp-mode "perspective" "Toggle perspective mode.
When active, keeps track of multiple 'perspectives',
named collections of buffers and window configurations.

This is a minor mode.  If called interactively, toggle the `Persp
mode' mode.  If the prefix argument is positive, enable the mode,
and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='persp-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (autoload 'persp-switch-to-buffer* "perspective" "Like `switch-to-buffer', restricted to the current perspective.
This respects ido-ignore-buffers, since we automatically add
buffer filtering to ido-mode already (see use of
PERSP-SET-IDO-BUFFERS).

(fn BUFFER-OR-NAME)" t nil) (autoload 'persp-kill-buffer* "perspective" "Like `kill-buffer', restricted to the current perspective.
This respects ido-ignore-buffers, since we automatically add
buffer filtering to ido-mode already (see use of
PERSP-SET-IDO-BUFFERS).

(fn BUFFER-OR-NAME)" t nil) (autoload 'persp-buffer-menu "perspective" "Like the default C-x C-b, but filters for the current perspective's buffers.

(fn ARG)" t nil) (autoload 'persp-list-buffers "perspective" "Like the default C-x C-b, but filters for the current perspective's buffers.

(fn ARG)" t nil) (autoload 'persp-bs-show "perspective" "Invoke BS-SHOW with a configuration enabled for Perspective.
With a prefix arg, show buffers in all perspectives.
This respects ido-ignore-buffers, since we automatically add
buffer filtering to ido-mode already (see use of
PERSP-SET-IDO-BUFFERS).

(fn ARG)" t nil) (autoload 'persp-ibuffer "perspective" "Invoke IBUFFER with a configuration enabled for Perspective.
With a prefix arg, show buffers in all perspectives.
This respects ido-ignore-buffers, since we automatically add
buffer filtering to ido-mode already (see use of
PERSP-SET-IDO-BUFFERS).

(fn ARG)" t nil) (autoload 'persp-ivy-switch-buffer "perspective" "A version of `ivy-switch-buffer' which respects perspectives.

(fn ARG)" t nil) (autoload 'persp-counsel-switch-buffer "perspective" "A version of `counsel-switch-buffer' which respects perspectives.

(fn ARG)" t nil) (autoload 'persp-state-save "perspective" "Save the current perspective state to FILE.

FILE defaults to the value of persp-state-default-file if it is
set.

Each perspective's buffer list and window layout will be saved.
Frames and their associated perspectives will also be saved,
but not the original frame sizes.

Buffers with * characters in their names, as well as buffers without
associated files will be ignored. If such buffers are currently
visible in a perspective as windows, they will be saved as
'*scratch* (persp)' buffers.

(fn &optional FILE INTERACTIVE\\=\\?)" t nil) (autoload 'persp-state-load "perspective" "Restore the perspective state saved in FILE.

FILE defaults to the value of persp-state-default-file if it is
set.

Frames are restored, along with each frame's perspective list.
Each perspective's buffer list and window layout are also
restored.

(fn FILE)" t nil) (autoload 'persp-ibuffer-generate-filter-groups "perspective" "Create a set of ibuffer filter groups based on the persp name of buffers." nil nil) (autoload 'persp-ibuffer-set-filter-groups "perspective" "Set the current filter groups to filter by persp name." t nil) (register-definition-prefixes "perspective" '("check-persp" "make-persp" "persp" "quick-perspective-keys" "with-")) (provide 'perspective-autoloads)) "gntp" ((gntp gntp-autoloads) (autoload 'gntp-notify "gntp" "Send notification NAME with TITLE, TEXT, PRIORITY and ICON to SERVER:PORT.
PORT defaults to `gntp-server-port'

(fn NAME TITLE TEXT SERVER &optional PORT PRIORITY ICON)" nil nil) (register-definition-prefixes "gntp" '("gntp-")) (provide 'gntp-autoloads)) "log4e" ((log4e log4e-autoloads) (autoload 'log4e-mode "log4e" "Major mode for browsing a buffer made by log4e.

\\<log4e-mode-map>
\\{log4e-mode-map}

(fn)" t nil) (autoload 'log4e:insert-start-log-quickly "log4e" "Insert logging statment for trace level log at start of current function/macro." t nil) (register-definition-prefixes "log4e" '("log4e")) (provide 'log4e-autoloads)) "alert" ((alert-autoloads alert) (autoload 'alert-add-rule "alert" "Programmatically add an alert configuration rule.

Normally, users should custoimze `alert-user-configuration'.
This facility is for module writers and users that need to do
things the Lisp way.

Here is a rule the author currently uses with ERC, so that the
fringe gets colored whenever people chat on BitlBee:

(alert-add-rule :status   \\='(buried visible idle)
                :severity \\='(moderate high urgent)
                :mode     \\='erc-mode
                :predicate
                #\\='(lambda (info)
                    (string-match (concat \"\\\\`[^&].*@BitlBee\\\\\\='\")
                                  (erc-format-target-and/or-network)))
                :persistent
                #\\='(lambda (info)
                    ;; If the buffer is buried, or the user has been
                    ;; idle for `alert-reveal-idle-time' seconds,
                    ;; make this alert persistent.  Normally, alerts
                    ;; become persistent after
                    ;; `alert-persist-idle-time' seconds.
                    (memq (plist-get info :status) \\='(buried idle)))
                :style \\='fringe
                :continue t)

(fn &key SEVERITY STATUS MODE CATEGORY TITLE MESSAGE PREDICATE ICON (STYLE alert-default-style) PERSISTENT CONTINUE NEVER-PERSIST APPEND)" nil nil) (autoload 'alert "alert" "Alert the user that something has happened.
MESSAGE is what the user will see.  You may also use keyword
arguments to specify additional details.  Here is a full example:

(alert \"This is a message\"
       :severity \\='high          ;; The default severity is `normal'
       :title \"Title\"           ;; An optional title
       :category \\='example       ;; A symbol to identify the message
       :mode \\='text-mode         ;; Normally determined automatically
       :buffer (current-buffer) ;; This is the default
       :data nil                ;; Unused by alert.el itself
       :persistent nil          ;; Force the alert to be persistent;
                                ;; it is best not to use this
       :never-persist nil       ;; Force this alert to never persist
       :id \\='my-id)              ;; Used to replace previous message of
                                ;; the same id in styles that support it
       :style \\='fringe)          ;; Force a given style to be used;
                                ;; this is only for debugging!

If no :title is given, the buffer-name of :buffer is used.  If
:buffer is nil, it is the current buffer at the point of call.

:data is an opaque value which modules can pass through to their
own styles if they wish.

Here are some more typical examples of usage:

  ;; This is the most basic form usage
  (alert \"This is an alert\")

  ;; You can adjust the severity for more important messages
  (alert \"This is an alert\" :severity \\='high)

  ;; Or decrease it for purely informative ones
  (alert \"This is an alert\" :severity \\='trivial)

  ;; Alerts can have optional titles.  Otherwise, the title is the
  ;; buffer-name of the (current-buffer) where the alert originated.
  (alert \"This is an alert\" :title \"My Alert\")

  ;; Further, alerts can have categories.  This allows users to
  ;; selectively filter on them.
  (alert \"This is an alert\" :title \"My Alert\"
         :category \\='some-category-or-other)

(fn MESSAGE &key (SEVERITY \\='normal) TITLE ICON CATEGORY BUFFER MODE DATA STYLE PERSISTENT NEVER-PERSIST ID)" nil nil) (register-definition-prefixes "alert" '("alert-" "x-urgen")) (provide 'alert-autoloads)) "super-save" ((super-save-autoloads super-save) (defvar super-save-mode nil "Non-nil if super-save mode is enabled.
See the `super-save-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `super-save-mode'.") (custom-autoload 'super-save-mode "super-save" nil) (autoload 'super-save-mode "super-save" "A minor mode that saves your Emacs buffers when they lose focus.

This is a minor mode.  If called interactively, toggle the
`super-save mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='super-save-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (register-definition-prefixes "super-save" '("super-save-")) (provide 'super-save-autoloads)) "evil-nerd-commenter" ((evil-nerd-commenter evil-nerd-commenter-sdk evil-nerd-commenter-autoloads evil-nerd-commenter-operator) (autoload 'evilnc-comment-or-uncomment-region-internal "evil-nerd-commenter" "Comment or uncomment region from START to END.

(fn START END)" nil nil) (autoload 'evilnc-comment-or-uncomment-region "evil-nerd-commenter" "Comment or uncomment region from START to END.

(fn START END)" nil nil) (autoload 'evilnc-comment-or-uncomment-paragraphs "evil-nerd-commenter" "Comment or uncomment NUM paragraph(s).
A paragraph is a continuation non-empty lines.
Paragraphs are separated by empty lines.

(fn &optional NUM)" t nil) (autoload 'evilnc-comment-or-uncomment-to-the-line "evil-nerd-commenter" "Comment or uncomment from current line to LINENUM line.

(fn &optional LINENUM)" t nil) (autoload 'evilnc-quick-comment-or-uncomment-to-the-line "evil-nerd-commenter" "Comment/uncomment to line number by LAST-DIGITS.
For example, you can use either \\<M-53>\\[evilnc-quick-comment-or-uncomment-to-the-line] or \\<M-3>\\[evilnc-quick-comment-or-uncomment-to-the-line] to comment to the line 6453

(fn &optional LAST-DIGITS)" t nil) (autoload 'evilnc-toggle-invert-comment-line-by-line "evil-nerd-commenter" "Please note this command may NOT work on complex evil text objects." t nil) (autoload 'evilnc-toggle-comment-empty-lines "evil-nerd-commenter" "Toggle the flag which decide if empty line will be commented." t nil) (autoload 'evilnc-comment-or-uncomment-lines "evil-nerd-commenter" "Comment or uncomment NUM lines.  NUM could be negative.

Case 1: If no region selected, comment/uncomment on current line.
If NUM>1, comment/uncomment extra N-1 lines from next line.

Case 2: Selected region is expanded to make it contain whole lines.
Then we comment/uncomment the expanded region.  NUM is ignored.

Case 3: If a region inside of ONE line is selected,
we comment/uncomment that region.
CORRECT comment syntax will be used for C++/Java/Javascript.

(fn &optional NUM)" t nil) (autoload 'evilnc-copy-and-comment-lines "evil-nerd-commenter" "Copy&paste NUM lines and comment out original lines.
NUM could be negative.

Case 1: If no region selected, operate on current line.
if NUM>1, comment/uncomment extra N-1 lines from next line

Case 2: Selected region is expanded to make it contain whole lines.
Then we operate the expanded region.  NUM is ignored.

(fn &optional NUM)" t nil) (autoload 'evilnc-comment-and-kill-ring-save "evil-nerd-commenter" "Comment lines save origin lines into `kill-ring'.
NUM could be negative.

Case 1: If no region selected, operate on current line.
;; if NUM>1, comment/uncomment extra N-1 lines from next line

Case 2: Selected region is expanded to make it contain whole lines.
Then we operate the expanded region.  NUM is ignored.

(fn &optional NUM)" t nil) (autoload 'evilnc-copy-to-line "evil-nerd-commenter" "Copy from current line to LINENUM line.  For non-evil user only.

(fn &optional LINENUM)" t nil) (autoload 'evilnc-kill-to-line "evil-nerd-commenter" "Kill from the current line to the LINENUM line.  For non-evil user only.

(fn &optional LINENUM)" t nil) (autoload 'evilnc-version "evil-nerd-commenter" "The version number." t nil) (autoload 'evilnc-default-hotkeys "evil-nerd-commenter" "Setup the key bindings of evil-nerd-comment.
If NO-EVIL-KEYBINDINGS is t, we don't define keybindings in EVIL,
if NO-EMACS-KEYBINDINGS is t, we don't define keybindings in EMACS mode.

(fn &optional NO-EVIL-KEYBINDINGS NO-EMACS-KEYBINDINGS)" t nil) (autoload 'evilnc-imenu-create-index-function "evil-nerd-commenter" "Imenu function find comments." nil nil) (autoload 'evilnc-comment-or-uncomment-html-tag "evil-nerd-commenter" "Comment or uncomment html tag(s).
If no region is selected, current tag under focus is automatically selected.
In this case, only one tag is selected.
If users manually select region, the region could cross multiple sibling tags
and automatically expands to include complete tags.
Users can press \"v\" key in evil mode to select multiple tags.
This command is not dependent on any 3rd party package." t nil) (autoload 'evilnc-comment-or-uncomment-html-paragraphs "evil-nerd-commenter" "Comment or uncomment NUM paragraphs contain html tag.
A paragraph is a continuation non-empty lines.
Paragraphs are separated by empty lines.

(fn &optional NUM)" t nil) (register-definition-prefixes "evil-nerd-commenter" '("evilnc-")) (register-definition-prefixes "evil-nerd-commenter-operator" '("evilnc-")) (register-definition-prefixes "evil-nerd-commenter-sdk" '("evilnc-")) (provide 'evil-nerd-commenter-autoloads)) "ws-butler" ((ws-butler-autoloads ws-butler) (autoload 'ws-butler-mode "ws-butler" "White space cleanup, without obtrusive white space removal.

This is a minor mode.  If called interactively, toggle the
`Ws-Butler mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `ws-butler-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

Whitespaces at EOL and EOF are trimmed upon file save, and only
for lines modified by you.

(fn &optional ARG)" t nil) (put 'ws-butler-global-mode 'globalized-minor-mode t) (defvar ws-butler-global-mode nil "Non-nil if Ws-Butler-Global mode is enabled.
See the `ws-butler-global-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `ws-butler-global-mode'.") (custom-autoload 'ws-butler-global-mode "ws-butler" nil) (autoload 'ws-butler-global-mode "ws-butler" "Toggle Ws-Butler mode in all buffers.
With prefix ARG, enable Ws-Butler-Global mode if ARG is positive;
otherwise, disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Ws-Butler mode is enabled in all buffers where `(lambda nil (unless
(apply #'derived-mode-p ws-butler-global-exempt-modes)
(ws-butler-mode)))' would do it.

See `ws-butler-mode' for more information on Ws-Butler mode.

(fn &optional ARG)" t nil) (register-definition-prefixes "ws-butler" '("ws-butler-")) (provide 'ws-butler-autoloads)) "parinfer" ((parinfer-ext parinfer parinferlib parinfer-autoloads) (autoload 'parinfer-mode "parinfer" "Parinfer mode.

This is a minor mode.  If called interactively, toggle the
`Parinfer mode' mode.  If the prefix argument is positive, enable
the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `parinfer-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (autoload 'parinfer-region-mode "parinfer" "Available when region is active.

This is a minor mode.  If called interactively, toggle the
`Parinfer-Region mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `parinfer-region-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (register-definition-prefixes "parinfer" '("parinfer-")) (register-definition-prefixes "parinfer-ext" '("parinfer-")) (register-definition-prefixes "parinferlib" '("parinferlib-")) (provide 'parinfer-autoloads)) "origami" ((origami origami-autoloads origami-parsers) (autoload 'origami-mode "origami" "Minor mode to selectively hide/show text in the current buffer.
With a prefix argument ARG, enable the mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable the mode
if ARG is omitted or nil.

Lastly, the normal hook `origami-mode-hook' is run using
`run-hooks'.

Key bindings:
\\{origami-mode-map}

(fn &optional ARG)" t nil) (put 'global-origami-mode 'globalized-minor-mode t) (defvar global-origami-mode nil "Non-nil if Global Origami mode is enabled.
See the `global-origami-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-origami-mode'.") (custom-autoload 'global-origami-mode "origami" nil) (autoload 'global-origami-mode "origami" "Toggle Origami mode in all buffers.
With prefix ARG, enable Global Origami mode if ARG is positive;
otherwise, disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Origami mode is enabled in all buffers where `(lambda nil
(origami-mode 1))' would do it.

See `origami-mode' for more information on Origami mode.

(fn &optional ARG)" t nil) (register-definition-prefixes "origami" '("origami-")) (register-definition-prefixes "origami-parsers" '("origami-")) (provide 'origami-autoloads)) "dotcrafter" ((dotcrafter-autoloads dotcrafter demo) (register-definition-prefixes "dotcrafter" '("dotcrafter-")) (provide 'dotcrafter-autoloads)) "lv" ((lv-autoloads lv) (register-definition-prefixes "lv" '("lv-")) (provide 'lv-autoloads)) "hydra" ((hydra hydra-ox hydra-examples hydra-autoloads) (autoload 'defhydra "hydra" "Create a Hydra - a family of functions with prefix NAME.

NAME should be a symbol, it will be the prefix of all functions
defined here.

BODY has the format:

    (BODY-MAP BODY-KEY &rest BODY-PLIST)

DOCSTRING will be displayed in the echo area to identify the
Hydra.  When DOCSTRING starts with a newline, special Ruby-style
substitution will be performed by `hydra--format'.

Functions are created on basis of HEADS, each of which has the
format:

    (KEY CMD &optional HINT &rest PLIST)

BODY-MAP is a keymap; `global-map' is used quite often.  Each
function generated from HEADS will be bound in BODY-MAP to
BODY-KEY + KEY (both are strings passed to `kbd'), and will set
the transient map so that all following heads can be called
though KEY only.  BODY-KEY can be an empty string.

CMD is a callable expression: either an interactive function
name, or an interactive lambda, or a single sexp (it will be
wrapped in an interactive lambda).

HINT is a short string that identifies its head.  It will be
printed beside KEY in the echo erea if `hydra-is-helpful' is not
nil.  If you don't even want the KEY to be printed, set HINT
explicitly to nil.

The heads inherit their PLIST from BODY-PLIST and are allowed to
override some keys.  The keys recognized are :exit, :bind, and :column.
:exit can be:

- nil (default): this head will continue the Hydra state.
- t: this head will stop the Hydra state.

:bind can be:
- nil: this head will not be bound in BODY-MAP.
- a lambda taking KEY and CMD used to bind a head.

:column is a string that sets the column for all subsequent heads.

It is possible to omit both BODY-MAP and BODY-KEY if you don't
want to bind anything.  In that case, typically you will bind the
generated NAME/body command.  This command is also the return
result of `defhydra'.

(fn NAME BODY &optional DOCSTRING &rest HEADS)" nil t) (function-put 'defhydra 'lisp-indent-function 'defun) (function-put 'defhydra 'doc-string-elt '3) (register-definition-prefixes "hydra" '("defhydra" "hydra-")) (register-definition-prefixes "hydra-examples" '("hydra-" "org-agenda-cts" "whitespace-mode")) (register-definition-prefixes "hydra-ox" '("hydra-ox")) (provide 'hydra-autoloads)) "corfu" ((corfu-autoloads corfu) (autoload 'corfu-mode "corfu" "Completion Overlay Region FUnction

This is a minor mode.  If called interactively, toggle the `Corfu
mode' mode.  If the prefix argument is positive, enable the mode,
and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `corfu-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (put 'corfu-global-mode 'globalized-minor-mode t) (defvar corfu-global-mode nil "Non-nil if Corfu-Global mode is enabled.
See the `corfu-global-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `corfu-global-mode'.") (custom-autoload 'corfu-global-mode "corfu" nil) (autoload 'corfu-global-mode "corfu" "Toggle Corfu mode in all buffers.
With prefix ARG, enable Corfu-Global mode if ARG is positive;
otherwise, disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Corfu mode is enabled in all buffers where `corfu--on' would do it.

See `corfu-mode' for more information on Corfu mode.

(fn &optional ARG)" t nil) (register-definition-prefixes "corfu" '("corfu-")) (provide 'corfu-autoloads)) "orderless" ((orderless orderless-autoloads) (autoload 'orderless-filter "orderless" "Split STRING into components and find entries TABLE matching all.
The predicate PRED is used to constrain the entries in TABLE.

(fn STRING TABLE &optional PRED)" nil nil) (autoload 'orderless-all-completions "orderless" "Split STRING into components and find entries TABLE matching all.
The predicate PRED is used to constrain the entries in TABLE.  The
matching portions of each candidate are highlighted.
This function is part of the `orderless' completion style.

(fn STRING TABLE PRED POINT)" nil nil) (autoload 'orderless-try-completion "orderless" "Complete STRING to unique matching entry in TABLE.
This uses `orderless-all-completions' to find matches for STRING
in TABLE among entries satisfying PRED.  If there is only one
match, it completes to that match.  If there are no matches, it
returns nil.  In any other case it \"completes\" STRING to
itself, without moving POINT.
This function is part of the `orderless' completion style.

(fn STRING TABLE PRED POINT)" nil nil) (add-to-list 'completion-styles-alist '(orderless orderless-try-completion orderless-all-completions "Completion of multiple components, in any order.")) (autoload 'orderless-ivy-re-builder "orderless" "Convert STR into regexps for use with ivy.
This function is for integration of orderless with ivy, use it as
a value in `ivy-re-builders-alist'.

(fn STR)" nil nil) (with-eval-after-load 'ivy (add-to-list 'ivy-highlight-functions-alist '(orderless-ivy-re-builder . orderless-ivy-highlight))) (register-definition-prefixes "orderless" '("orderless-")) (provide 'orderless-autoloads)) "consult" ((consult consult-flymake consult-autoloads) (defvar consult-preview-mode nil "Non-nil if Consult-Preview mode is enabled.
See the `consult-preview-mode' command
for a description of this minor mode.") (custom-autoload 'consult-preview-mode "consult" nil) (autoload 'consult-preview-mode "consult" "Enable preview for consult commands.

This is a minor mode.  If called interactively, toggle the
`Consult-Preview mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='consult-preview-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (autoload 'consult-multi-occur "consult" "Improved version of `multi-occur' based on `completing-read-multiple'.

See `multi-occur' for the meaning of the arguments BUFS, REGEXP and NLINES.

(fn BUFS REGEXP &optional NLINES)" t nil) (autoload 'consult-outline "consult" "Jump to an outline heading.

This command supports candidate preview." t nil) (autoload 'consult-error "consult" "Jump to a compliation error in the current buffer.

This command works in compilation buffers and grep buffers.
The command supports preview of the currently selected error." t nil) (autoload 'consult-mark "consult" "Jump to a marker in the buffer-local `mark-ring'.

The command supports preview of the currently selected marker position." t nil) (autoload 'consult-global-mark "consult" "Jump to a marker in `global-mark-ring'.

The command supports preview of the currently selected marker position." t nil) (autoload 'consult-line "consult" "Search for a matching line and jump to the line beginning.

The default candidate is a non-empty line closest to point.
This command obeys narrowing. Optionally INITIAL input can be provided.

(fn &optional INITIAL)" t nil) (autoload 'consult-goto-line "consult" "Read line number and jump to the line with preview.

The command respects narrowing and the settings
`consult-goto-line-numbers' and `consult-line-numbers-widen'." t nil) (autoload 'consult-recent-file "consult" "Find recent using `completing-read'." t nil) (autoload 'consult-recent-file-other-frame "consult" "Find recent using `completing-read'." t nil) (autoload 'consult-recent-file-other-window "consult" "Find recent using `completing-read'." t nil) (autoload 'consult-file-externally "consult" "Open FILE externally using the default application of the system.

(fn FILE)" t nil) (autoload 'consult-completion-in-region "consult" "Prompt for completion of region in the minibuffer if non-unique.

The function is called with 4 arguments: START END COLLECTION PREDICATE.
The arguments and expected return value are as specified for
`completion-in-region'. Use as a value for `completion-in-region-function'.

(fn START END COLLECTION &optional PREDICATE)" nil nil) (autoload 'consult-mode-command "consult" "Run a command from any of the given MODES.

If no MODES are specified, use currently active major and minor modes.

(fn &rest MODES)" t nil) (autoload 'consult-yank "consult" "Select text from the kill ring and insert it." t nil) (autoload 'consult-yank-pop "consult" "If there is a recent yank act like `yank-pop'.

Otherwise select text from the kill ring and insert it.
See `yank-pop' for the meaning of ARG.

(fn &optional ARG)" t nil) (autoload 'consult-yank-replace "consult" "Select text from the kill ring.

If there was no recent yank, insert the text.
Otherwise replace the just-yanked text with the selected text." t nil) (autoload 'consult-register "consult" "Use register REG and either jump to location or insert the stored text.

(fn REG)" t nil) (autoload 'consult-bookmark "consult" "If bookmark NAME exists, open it, otherwise create a new bookmark with NAME.

The command supports preview of file bookmarks and narrowing.

(fn NAME)" t nil) (autoload 'consult-apropos "consult" "Select pattern and call `apropos'." t nil) (autoload 'consult-complex-command "consult" "Select and evaluate command from the command history.

This command can act as a drop-in replacement for `repeat-complex-command'." t nil) (autoload 'consult-history "consult" "Insert string from HISTORY of current buffer.

In order to select from a specific HISTORY, pass the history variable as argument.

(fn &optional HISTORY)" t nil) (autoload 'consult-minor-mode-menu "consult" "Enable or disable minor mode.

This is an alternative to `minor-mode-menu-from-indicator'." t nil) (autoload 'consult-theme "consult" "Disable current themes and enable THEME from `consult-themes'.

The command supports previewing the currently selected theme.

(fn THEME)" t nil) (autoload 'consult-buffer-other-frame "consult" "Enhanced `switch-to-buffer-other-frame' with support for virtual buffers.

See `consult-buffer'." t nil) (autoload 'consult-buffer-other-window "consult" "Enhanced `switch-to-buffer-other-window' with support for virtual buffers.

See `consult-buffer'." t nil) (autoload 'consult-buffer "consult" "Enhanced `switch-to-buffer' command with support for virtual buffers.

The command supports recent files, bookmarks, views and project files
as virtual buffers. Buffers are previewed. Furthermore narrowing
to buffers (b), files (f), bookmarks (m), views (v) and project files (p)
is supported via the corresponding keys." t nil) (autoload 'consult-kmacro "consult" "Run a chosen keyboard macro.  With prefix ARG, run the macro that many times.

Macros containing mouse clicks aren't displayed.

(fn ARG)" t nil) (autoload 'consult-imenu "consult" "Choose item from flattened `imenu' using `completing-read' with preview.

See also `consult-project-imenu'." t nil) (autoload 'consult-project-imenu "consult" "Choose item from the imenus of all buffers from the same project.

Only the buffers with the same major mode as the current buffer are
used. See also `consult-imenu'." t nil) (autoload 'consult-grep "consult" "Search for regexp with grep in DIR with INITIAL input.

(fn &optional DIR INITIAL)" t nil) (autoload 'consult-git-grep "consult" "Search for regexp with grep in DIR with INITIAL input.

(fn &optional DIR INITIAL)" t nil) (autoload 'consult-ripgrep "consult" "Search for regexp with rg in DIR with INITIAL input.

(fn &optional DIR INITIAL)" t nil) (autoload 'consult-find "consult" "Search for regexp with find in DIR.

(fn &optional DIR)" t nil) (autoload 'consult-locate "consult" "Search for regexp with locate." t nil) (register-definition-prefixes "consult" '("consult-")) (autoload 'consult-flymake "consult-flymake" "Jump to Flymake diagnostic." t nil) (register-definition-prefixes "consult-flymake" '("consult-")) (provide 'consult-autoloads)) "marginalia" ((marginalia marginalia-autoloads) (defvar marginalia-mode nil "Non-nil if Marginalia mode is enabled.
See the `marginalia-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `marginalia-mode'.") (custom-autoload 'marginalia-mode "marginalia" nil) (autoload 'marginalia-mode "marginalia" "Annotate completion candidates with richer information.

This is a minor mode.  If called interactively, toggle the
`Marginalia mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='marginalia-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (autoload 'marginalia-cycle "marginalia" "Cycle between annotators in `marginalia-annotators'.
If called from the minibuffer the annotator cycling is local,
that it is, it does not affect subsequent minibuffers.  When called
from a regular buffer the effect is global." t nil) (register-definition-prefixes "marginalia" '("marginalia-")) (provide 'marginalia-autoloads)) "embark" ((embark-autoloads embark) (defun embark--record-this-command nil "Record command which opened the minibuffer.
We record this because `embark-default-action' needs to know it.
This function is meant to be added to `minibuffer-setup-hook'." (setq-local embark--command this-command)) (add-hook 'minibuffer-setup-hook #'embark--record-this-command) (autoload 'embark-act-noexit "embark" "Embark upon an action.
The target of the action is chosen by `embark-target-finders'.
By default, if called from a minibuffer the target is the top
completion candidate, if called from an Embark Occur or a
Completions buffer it is the candidate at point." t nil) (autoload 'embark-act "embark" "Embark upon an action and exit from all minibuffers (if any).
The target of the action is chosen by `embark-target-finders'.
By default, if called from a minibuffer the target is the top
completion candidate, if called from an Embark Occur or a
Completions buffer it ixs the candidate at point." t nil) (autoload 'embark-become "embark" "Make current command become a different command.
Take the current minibuffer input as initial input for new
command.  The new command can be run normally using keybindings or
\\[execute-extended-command], but if the current command is found in a keymap in
`embark-become-keymaps', that keymap is activated to provide
convenient access to the other commands in it." t nil) (autoload 'embark-live-occur "embark" "Create a live-updating Embark Occur buffer.
Optionally start in INITIAL-VIEW (either `list' or `grid')
instead of what `embark-occur-initial-view-alist' specifies.
Interactively, \\[universal-argument] means grid view, a prefix
argument of 1 means list view.

To control the display, add an entry to `display-buffer-alist'
with key \"Embark Live Occur\".

(fn &optional INITIAL-VIEW)" t nil) (autoload 'embark-occur "embark" "Create an Embark Occur buffer and exit all minibuffers.
Optionally start in INITIAL-VIEW (either `list' or `grid')
instead of what `embark-occur-initial-view-alist' specifies.
Interactively, \\[universal-argument] means grid view, a prefix
argument of 1 means list view.

To control the display, add an entry to `display-buffer-alist'
with key \"Embark Occur\".

(fn &optional INITIAL-VIEW)" t nil) (autoload 'embark-switch-to-live-occur "embark" "Switch to the Embark Live Occur buffer, creating it if necessary." t nil) (autoload 'embark-export "embark" "Create a type-specific buffer to manage current candidates.
The variable `embark-exporters-alist' controls how to make the
buffer for each type of completion." t nil) (register-definition-prefixes "embark" '("embark-")) (provide 'embark-autoloads)) "avy" ((avy avy-autoloads) (autoload 'avy-process "avy" "Select one of CANDIDATES using `avy-read'.
Use OVERLAY-FN to visualize the decision overlay.
CLEANUP-FN should take no arguments and remove the effects of
multiple OVERLAY-FN invocations.

(fn CANDIDATES &optional OVERLAY-FN CLEANUP-FN)" nil nil) (autoload 'avy-goto-char "avy" "Jump to the currently visible CHAR.
The window scope is determined by `avy-all-windows' (ARG negates it).

(fn CHAR &optional ARG)" t nil) (autoload 'avy-goto-char-in-line "avy" "Jump to the currently visible CHAR in the current line.

(fn CHAR)" t nil) (autoload 'avy-goto-char-2 "avy" "Jump to the currently visible CHAR1 followed by CHAR2.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.
BEG and END narrow the scope where candidates are searched.

(fn CHAR1 CHAR2 &optional ARG BEG END)" t nil) (autoload 'avy-goto-char-2-above "avy" "Jump to the currently visible CHAR1 followed by CHAR2.
This is a scoped version of `avy-goto-char-2', where the scope is
the visible part of the current buffer up to point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

(fn CHAR1 CHAR2 &optional ARG)" t nil) (autoload 'avy-goto-char-2-below "avy" "Jump to the currently visible CHAR1 followed by CHAR2.
This is a scoped version of `avy-goto-char-2', where the scope is
the visible part of the current buffer following point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

(fn CHAR1 CHAR2 &optional ARG)" t nil) (autoload 'avy-isearch "avy" "Jump to one of the current isearch candidates." t nil) (autoload 'avy-goto-word-0 "avy" "Jump to a word start.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.
BEG and END narrow the scope where candidates are searched.

(fn ARG &optional BEG END)" t nil) (autoload 'avy-goto-whitespace-end "avy" "Jump to the end of a whitespace sequence.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.
BEG and END narrow the scope where candidates are searched.

(fn ARG &optional BEG END)" t nil) (autoload 'avy-goto-word-1 "avy" "Jump to the currently visible CHAR at a word start.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.
BEG and END narrow the scope where candidates are searched.
When SYMBOL is non-nil, jump to symbol start instead of word start.

(fn CHAR &optional ARG BEG END SYMBOL)" t nil) (autoload 'avy-goto-word-1-above "avy" "Jump to the currently visible CHAR at a word start.
This is a scoped version of `avy-goto-word-1', where the scope is
the visible part of the current buffer up to point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

(fn CHAR &optional ARG)" t nil) (autoload 'avy-goto-word-1-below "avy" "Jump to the currently visible CHAR at a word start.
This is a scoped version of `avy-goto-word-1', where the scope is
the visible part of the current buffer following point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

(fn CHAR &optional ARG)" t nil) (autoload 'avy-goto-symbol-1 "avy" "Jump to the currently visible CHAR at a symbol start.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

(fn CHAR &optional ARG)" t nil) (autoload 'avy-goto-symbol-1-above "avy" "Jump to the currently visible CHAR at a symbol start.
This is a scoped version of `avy-goto-symbol-1', where the scope is
the visible part of the current buffer up to point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

(fn CHAR &optional ARG)" t nil) (autoload 'avy-goto-symbol-1-below "avy" "Jump to the currently visible CHAR at a symbol start.
This is a scoped version of `avy-goto-symbol-1', where the scope is
the visible part of the current buffer following point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

(fn CHAR &optional ARG)" t nil) (autoload 'avy-goto-subword-0 "avy" "Jump to a word or subword start.
The window scope is determined by `avy-all-windows' (ARG negates it).

When PREDICATE is non-nil it's a function of zero parameters that
should return true.

BEG and END narrow the scope where candidates are searched.

(fn &optional ARG PREDICATE BEG END)" t nil) (autoload 'avy-goto-subword-1 "avy" "Jump to the currently visible CHAR at a subword start.
The window scope is determined by `avy-all-windows' (ARG negates it).
The case of CHAR is ignored.

(fn CHAR &optional ARG)" t nil) (autoload 'avy-goto-word-or-subword-1 "avy" "Forward to `avy-goto-subword-1' or `avy-goto-word-1'.
Which one depends on variable `subword-mode'." t nil) (autoload 'avy-goto-line "avy" "Jump to a line start in current buffer.

When ARG is 1, jump to lines currently visible, with the option
to cancel to `goto-line' by entering a number.

When ARG is 4, negate the window scope determined by
`avy-all-windows'.

Otherwise, forward to `goto-line' with ARG.

(fn &optional ARG)" t nil) (autoload 'avy-goto-line-above "avy" "Goto visible line above the cursor.
OFFSET changes the distance between the closest key to the cursor and
the cursor
When BOTTOM-UP is non-nil, display avy candidates from top to bottom

(fn &optional OFFSET BOTTOM-UP)" t nil) (autoload 'avy-goto-line-below "avy" "Goto visible line below the cursor.
OFFSET changes the distance between the closest key to the cursor and
the cursor
When BOTTOM-UP is non-nil, display avy candidates from top to bottom

(fn &optional OFFSET BOTTOM-UP)" t nil) (autoload 'avy-goto-end-of-line "avy" "Call `avy-goto-line' and move to the end of the line.

(fn &optional ARG)" t nil) (autoload 'avy-copy-line "avy" "Copy a selected line above the current line.
ARG lines can be used.

(fn ARG)" t nil) (autoload 'avy-move-line "avy" "Move a selected line above the current line.
ARG lines can be used.

(fn ARG)" t nil) (autoload 'avy-copy-region "avy" "Select two lines and copy the text between them to point.

The window scope is determined by `avy-all-windows' or
`avy-all-windows-alt' when ARG is non-nil.

(fn ARG)" t nil) (autoload 'avy-move-region "avy" "Select two lines and move the text between them above the current line." t nil) (autoload 'avy-kill-region "avy" "Select two lines and kill the region between them.

The window scope is determined by `avy-all-windows' or
`avy-all-windows-alt' when ARG is non-nil.

(fn ARG)" t nil) (autoload 'avy-kill-ring-save-region "avy" "Select two lines and save the region between them to the kill ring.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

(fn ARG)" t nil) (autoload 'avy-kill-whole-line "avy" "Select line and kill the whole selected line.

With a numerical prefix ARG, kill ARG line(s) starting from the
selected line.  If ARG is negative, kill backward.

If ARG is zero, kill the selected line but exclude the trailing
newline.

\\[universal-argument] 3 \\[avy-kil-whole-line] kill three lines
starting from the selected line.  \\[universal-argument] -3

\\[avy-kill-whole-line] kill three lines backward including the
selected line.

(fn ARG)" t nil) (autoload 'avy-kill-ring-save-whole-line "avy" "Select line and save the whole selected line as if killed, but don\342\200\231t kill it.

This command is similar to `avy-kill-whole-line', except that it
saves the line(s) as if killed, but does not kill it(them).

With a numerical prefix ARG, kill ARG line(s) starting from the
selected line.  If ARG is negative, kill backward.

If ARG is zero, kill the selected line but exclude the trailing
newline.

(fn ARG)" t nil) (autoload 'avy-setup-default "avy" "Setup the default shortcuts." nil nil) (autoload 'avy-goto-char-timer "avy" "Read one or many consecutive chars and jump to the first one.
The window scope is determined by `avy-all-windows' (ARG negates it).

(fn &optional ARG)" t nil) (autoload 'avy-transpose-lines-in-region "avy" "Transpose lines in the active region." t nil) (register-definition-prefixes "avy" '("avy-")) (provide 'avy-autoloads)) "dash-functional" ((dash-functional dash-functional-autoloads) (register-definition-prefixes "dash-functional" '("-a" "-c" "-f" "-iteratefn" "-juxt" "-not" "-o" "-prodfn" "-rpartial")) (provide 'dash-functional-autoloads)) "pretty-hydra" ((pretty-hydra-autoloads pretty-hydra) (autoload 'pretty-hydra-define "pretty-hydra" "Define a pretty hydra with given NAME, BODY options and HEADS-PLIST.
The generated hydra has a nice-looking docstring which is a table
with columns of command keys and hints.

NAME should be a symbol and is passed to `defhydra' as is.

BODY is the same as that in `defhydra', withe the following
pretty hydra specific ones:

  - `:separator' a single char used to generate the separator
    line.

  - `:title' a string that's added to the beginning of the
    docstring as a title of the hydra.

  - `:formatter' a function that takes the generated docstring
    and return a decorated one.  It can be used to further
    customize the hydra docstring.

  - `:quit-key' a key of list of keys for quitting the hydra.
    When specified, invisible head(s) are created with the
    specified keys for quitting the hydra.

HEADS-PLIST is a plist of columns of hydra heads.  The keys of
the plist should be column names.  The values should be lists of
hydra heads.  Each head has exactly the same syntax as that of
`defhydra', except hint is required for the head to appear in the
docstring.  The following additional options are supported:

  - `:width' the max width of a dynamic hint, used to calculate
    the final width of the entire column.  It is ignored when the
    hint is a string.

  - `:toggle' when specified, it makes the head a toggle and adds
    an indicator to the end of the hint for the status of the
    toggle.  The value of this option can be a symbol, an s-exp
    or t.  The toggle status is read from the given variable, by
    evaluating the given expression or checking the `cmd' as if
    it's a variable.  The latter is especially useful for minior
    modes, e.g.

       (\"n\" `linum-mode' \"line number\" :toggle t)

(fn NAME BODY HEADS-PLIST)" nil t) (function-put 'pretty-hydra-define 'lisp-indent-function 'defun) (autoload 'pretty-hydra-define+ "pretty-hydra" "Redefine an existing pretty-hydra by adding new HEADS-PLIST.
If heads are added to a column already in NAME, the heads are
appended to that column.  Existing BODY is replaced with the new
one if specified.  Arguments are the same as `pretty-hydra-define'.

(fn NAME BODY HEADS-PLIST)" nil t) (function-put 'pretty-hydra-define+ 'lisp-indent-function 'defun) (autoload 'pretty-hydra-toggle "pretty-hydra" "Create a dynamic hint that look like a radio button with given NAME.
Radio is considered on when STATUS is non-nil, otherwise off.

(fn NAME STATUS)" nil nil) (register-definition-prefixes "pretty-hydra" '("pretty-hydra-")) (provide 'pretty-hydra-autoloads)) "magit-section" ((magit-section magit-section-autoloads) (register-definition-prefixes "magit-section" '("isearch-clean-overlays@magit-mode" "magit-")) (provide 'magit-section-autoloads)) "bufler" ((bufler-autoloads bufler-workspace bufler-group-tree bufler-workspace-tabs bufler) (autoload 'bufler-list "bufler" "Show Bufler's list.
With prefix argument ARG, force refreshing of buffers' VC state,
clear `bufler-cache', and regenerate buffer groups (which can be
useful after changing `bufler-groups' if the buffer list has not
yet changed).  With two universal prefix args, also show buffers
which are otherwise filtered by `bufler-filter-buffer-fns'.

(fn &optional ARG)" t nil) (defalias 'bufler #'bufler-list) (defalias 'bufler-switch-buffer #'bufler-workspace-switch-buffer) (defalias 'bufler-mode #'bufler-workspace-mode) (autoload 'bufler-defgroups "bufler" "Expand GROUPS into a group definition suitable for `bufler-groups'.
See documentation for details.

(fn &rest GROUPS)" nil t) (function-put 'bufler-defgroups 'lisp-indent-function 'defun) (register-definition-prefixes "bufler" '("bufler-")) (register-definition-prefixes "bufler-group-tree" '("bufler-group-tree")) (autoload 'bufler-workspace-frame-set "bufler-workspace" "Set workspace for the current frame to the one at PATH.
Interactively, choose workspace path with completion.  If PATH is
nil (interactively, with prefix), unset the frame's workspace.
Return the workspace path.

(fn &optional PATH)" t nil) (autoload 'bufler-workspace-focus-buffer "bufler-workspace" "Set current frame's workspace to BUFFER's workspace.
Interactively, use current buffer.

(fn BUFFER)" t nil) (autoload 'bufler-workspace-switch-buffer "bufler-workspace" "Switch to another buffer in the current group.
Without any input, switch to the previous buffer, like
`switch-to-buffer'.  If ALL-P (interactively, with universal
prefix) or if the frame has no workspace, select from all
buffers.  If SET-WORKSPACE-P (with two universal prefixes),
select from all buffers and set the frame's workspace.  If
NO-FILTER (with three universal prefixes), include buffers that
would otherwise be filtered by
`bufler-workspace-switch-buffer-filter-fns'.

If `bufler-workspace-switch-buffer-sets-workspace' is non-nil,
act as if SET-WORKSPACE-P is non-nil.

(fn &optional ALL-P SET-WORKSPACE-P NO-FILTER)" t nil) (autoload 'bufler-workspace-buffer-name-workspace "bufler-workspace" "Set current buffer's workspace to NAME.
If NAME is nil (interactively, with prefix), unset the buffer's
workspace name.  This sets the buffer-local variable
`bufler-workspace-name'.  Note that, in order for a buffer to
appear in a named workspace, the buffer must be matched by an
`auto-workspace' group before any other group.

(fn &optional NAME)" t nil) (defvar bufler-workspace-mode nil "Non-nil if Bufler-Workspace mode is enabled.
See the `bufler-workspace-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `bufler-workspace-mode'.") (custom-autoload 'bufler-workspace-mode "bufler-workspace" nil) (autoload 'bufler-workspace-mode "bufler-workspace" "When active, set the frame title according to current Bufler group.

This is a minor mode.  If called interactively, toggle the
`Bufler-Workspace mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='bufler-workspace-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (register-definition-prefixes "bufler-workspace" '("bufler-workspace-")) (when (require 'tab-bar nil t) (require 'tab-line) (defvar bufler-workspace-tabs-mode-saved-settings '((tab-bar-separator) (tab-bar-close-button-show)) "Settings saved from before `bufler-workspace-tabs-mode' was activated.
Used to restore them when the mode is disabled.") (defcustom bufler-workspace-tabs-tab-separator " | " "String displayed between tabs.
Since there is no built-in separator between tabs, it can be
unclear where one tab ends and the next begins, depending on face
settings.  Normally the tab-close button would indicate where a
tab ends, but our tabs are dynamic, rule-generated workspaces and
aren't closable manually, so we repurpose the
`tab-bar-close-button' as a separator.

This string can be anything, including an image using display
properties.  See the default value of `tab-bar-close-button'." :type 'string :group 'bufler-workspace) (define-minor-mode bufler-workspace-tabs-mode "Use Bufler workspaces for `tab-bar-mode' and `tab-line-mode'." :group 'bufler-workspace :global t (if bufler-workspace-tabs-mode (progn (cl-loop for (symbol . _value) in bufler-workspace-tabs-mode-saved-settings do (setf (map-elt bufler-workspace-tabs-mode-saved-settings symbol) (symbol-value symbol))) (advice-add 'tab-bar-select-tab :override #'bufler-workspace-tabs--tab-bar-select-tab) (advice-add 'tab-bar-switch-to-tab :override #'bufler-workspace-frame-set) (setf tab-bar-tabs-function #'bufler-workspace-tabs tab-line-tabs-function #'bufler-workspace-buffers) (tab-bar-mode 1) (global-tab-line-mode 1) (setf tab-bar-separator bufler-workspace-tabs-tab-separator tab-bar-close-button-show nil)) (advice-remove 'tab-bar-select-tab #'bufler-workspace-tabs--tab-bar-select-tab) (advice-remove 'tab-bar-switch-to-tab #'bufler-workspace-frame-set) (setf tab-bar-tabs-function #'tab-bar-tabs tab-line-tabs-function #'tab-line-tabs-window-buffers) (cl-loop for (symbol . value) in bufler-workspace-tabs-mode-saved-settings do (set symbol value) do (setf (map-elt bufler-workspace-tabs-mode-saved-settings symbol) nil)) (tab-bar-mode -1) (global-tab-line-mode -1)) (force-mode-line-update 'all)) (defalias 'bufler-tabs-mode #'bufler-workspace-tabs-mode) (defun bufler-workspace-tabs--tab-bar-select-tab (&optional arg) "Set the frame's workspace to the selected tab's workspace.
ARG is the position of the tab in the tab bar." (interactive "P") (unless (integerp arg) (let ((key (event-basic-type last-command-event))) (setq arg (if (and (characterp key) (>= key 49) (<= key 57)) (- key 48) 1)))) (let* ((tabs (funcall tab-bar-tabs-function)) (from-index (tab-bar--current-tab-index tabs)) (to-index (1- (max 1 (min arg (length tabs)))))) (unless (eq from-index to-index) (let* ((_from-tab (tab-bar--tab)) (to-tab (nth to-index tabs)) (workspace-path (alist-get 'path to-tab))) (bufler-workspace-frame-set workspace-path) (force-mode-line-update 'all))))) (defun bufler-workspace-tabs (&optional frame) "Return a list of workspace tabs from FRAME's perspective.
FRAME defaults to the selected frame.  Works as
`tab-bar-tabs-function'." (with-selected-frame (or frame (selected-frame)) (cl-labels ((tab-type (path) (if (equal path (frame-parameter nil 'bufler-workspace-path)) 'current-tab 'tab)) (path-first (path) (cl-typecase path (string (list path)) (list (if (car path) (list (car path)) (list (cadr path)))))) (workspace-to-tab (workspace &optional type) (-let* (((&plist :name :path) workspace)) (list (or type (tab-type path)) (cons 'name (car name)) (cons 'path path)))) (path-top-level (path) (pcase-exhaustive path (`(,(and first (guard (not first))) ,(and second (guard second)) \, _rest) (ignore first second) (cl-subseq path 0 2)) (`(,first \, _rest) (list first)))) (path-to-workspace (path) (list :name (path-first path) :path path))) (let* ((bufler-vc-refresh nil) (buffer-paths (bufler-group-tree-paths (bufler-buffers))) (group-paths (mapcar #'butlast buffer-paths)) (top-level-paths (mapcar #'path-top-level group-paths)) (top-level-workspaces (mapcar #'path-to-workspace top-level-paths)) (unique-top-level-workspaces (seq-uniq top-level-workspaces #'equal)) (tabs (mapcar #'workspace-to-tab unique-top-level-workspaces))) (unless (cl-loop with current-path = (frame-parameter nil 'bufler-workspace-path) for tab in tabs for tab-path = (alist-get 'path tab) thereis (equal tab-path current-path)) (push (list 'current-tab (cons 'name (bufler-format-path (frame-parameter nil 'bufler-workspace-path))) (cons 'path (frame-parameter nil 'bufler-workspace-path))) tabs)) tabs))))) (provide 'bufler-autoloads)) "default-text-scale" ((default-text-scale-autoloads default-text-scale) (autoload 'default-text-scale-increase "default-text-scale" "Increase the height of the default face by `default-text-scale-amount'." t nil) (autoload 'default-text-scale-decrease "default-text-scale" "Decrease the height of the default face by `default-text-scale-amount'." t nil) (autoload 'default-text-scale-reset "default-text-scale" "Reset the height of the default face.
With prefix argument SET-CURRENT, set the current size as the
default to which subsequent sizes would be reset.

(fn &optional SET-CURRENT)" t nil) (defvar default-text-scale-mode nil "Non-nil if Default-Text-Scale mode is enabled.
See the `default-text-scale-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `default-text-scale-mode'.") (custom-autoload 'default-text-scale-mode "default-text-scale" nil) (autoload 'default-text-scale-mode "default-text-scale" "Change the size of the \"default\" face in every frame.

This is a minor mode.  If called interactively, toggle the
`Default-Text-Scale mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='default-text-scale-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (register-definition-prefixes "default-text-scale" '("default-text-scale-")) (provide 'default-text-scale-autoloads)) "ace-window" ((ace-window-autoloads ace-window) (autoload 'ace-select-window "ace-window" "Ace select window." t nil) (autoload 'ace-delete-window "ace-window" "Ace delete window." t nil) (autoload 'ace-swap-window "ace-window" "Ace swap window." t nil) (autoload 'ace-delete-other-windows "ace-window" "Ace delete other windows." t nil) (autoload 'ace-display-buffer "ace-window" "Make `display-buffer' and `pop-to-buffer' select using `ace-window'.
See sample config for `display-buffer-base-action' and `display-buffer-alist':
https://github.com/abo-abo/ace-window/wiki/display-buffer.

(fn BUFFER ALIST)" nil nil) (autoload 'ace-window "ace-window" "Select a window.
Perform an action based on ARG described below.

By default, behaves like extended `other-window'.
See `aw-scope' which extends it to work with frames.

Prefixed with one \\[universal-argument], does a swap between the
selected window and the current window, so that the selected
buffer moves to current window (and current buffer moves to
selected window).

Prefixed with two \\[universal-argument]'s, deletes the selected
window.

(fn ARG)" t nil) (defvar ace-window-display-mode nil "Non-nil if Ace-Window-Display mode is enabled.
See the `ace-window-display-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `ace-window-display-mode'.") (custom-autoload 'ace-window-display-mode "ace-window" nil) (autoload 'ace-window-display-mode "ace-window" "Minor mode for showing the ace window key in the mode line.

This is a minor mode.  If called interactively, toggle the
`Ace-Window-Display mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='ace-window-display-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (register-definition-prefixes "ace-window" '("ace-window-mode" "aw-")) (provide 'ace-window-autoloads)) "visual-fill-column" ((visual-fill-column-autoloads visual-fill-column) (autoload 'visual-fill-column-mode "visual-fill-column" "Wrap lines according to `fill-column' in `visual-line-mode'.

This is a minor mode.  If called interactively, toggle the
`Visual-Fill-Column mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `visual-fill-column-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (put 'global-visual-fill-column-mode 'globalized-minor-mode t) (defvar global-visual-fill-column-mode nil "Non-nil if Global Visual-Fill-Column mode is enabled.
See the `global-visual-fill-column-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-visual-fill-column-mode'.") (custom-autoload 'global-visual-fill-column-mode "visual-fill-column" nil) (autoload 'global-visual-fill-column-mode "visual-fill-column" "Toggle Visual-Fill-Column mode in all buffers.
With prefix ARG, enable Global Visual-Fill-Column mode if ARG is
positive; otherwise, disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Visual-Fill-Column mode is enabled in all buffers where
`turn-on-visual-fill-column-mode' would do it.

See `visual-fill-column-mode' for more information on
Visual-Fill-Column mode.

(fn &optional ARG)" t nil) (autoload 'visual-fill-column-split-window-sensibly "visual-fill-column" "Split WINDOW sensibly, unsetting its margins first.
This function unsets the window margins and calls
`split-window-sensibly'.

By default, `split-window-sensibly' does not split a window in
two side-by-side windows if it has wide margins, even if there is
enough space for a vertical split.  This function is used as the
value of `split-window-preferred-function' to allow
`display-buffer' to split such windows.

(fn &optional WINDOW)" nil nil) (register-definition-prefixes "visual-fill-column" '("turn-on-visual-fill-column-mode" "visual-fill-column-")) (provide 'visual-fill-column-autoloads)) "popper" ((popper popper-echo)) "with-editor" ((with-editor-autoloads with-editor) (autoload 'with-editor-export-editor "with-editor" "Teach subsequent commands to use current Emacs instance as editor.

Set and export the environment variable ENVVAR, by default
\"EDITOR\".  The value is automatically generated to teach
commands to use the current Emacs instance as \"the editor\".

This works in `shell-mode', `term-mode', `eshell-mode' and
`vterm'.

(fn &optional (ENVVAR \"EDITOR\"))" t nil) (autoload 'with-editor-export-git-editor "with-editor" "Like `with-editor-export-editor' but always set `$GIT_EDITOR'." t nil) (autoload 'with-editor-export-hg-editor "with-editor" "Like `with-editor-export-editor' but always set `$HG_EDITOR'." t nil) (defvar shell-command-with-editor-mode nil "Non-nil if Shell-Command-With-Editor mode is enabled.
See the `shell-command-with-editor-mode' command
for a description of this minor mode.") (custom-autoload 'shell-command-with-editor-mode "with-editor" nil) (autoload 'shell-command-with-editor-mode "with-editor" "Teach `shell-command' to use current Emacs instance as editor.

This is a minor mode.  If called interactively, toggle the
`Shell-Command-With-Editor mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='shell-command-with-editor-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

Teach `shell-command', and all commands that ultimately call that
command, to use the current Emacs instance as editor by executing
\"EDITOR=CLIENT COMMAND&\" instead of just \"COMMAND&\".

CLIENT is automatically generated; EDITOR=CLIENT instructs
COMMAND to use to the current Emacs instance as \"the editor\",
assuming no other variable overrides the effect of \"$EDITOR\".
CLIENT may be the path to an appropriate emacsclient executable
with arguments, or a script which also works over Tramp.

Alternatively you can use the `with-editor-async-shell-command',
which also allows the use of another variable instead of
\"EDITOR\".

(fn &optional ARG)" t nil) (autoload 'with-editor-async-shell-command "with-editor" "Like `async-shell-command' but with `$EDITOR' set.

Execute string \"ENVVAR=CLIENT COMMAND\" in an inferior shell;
display output, if any.  With a prefix argument prompt for an
environment variable, otherwise the default \"EDITOR\" variable
is used.  With a negative prefix argument additionally insert
the COMMAND's output at point.

CLIENT is automatically generated; ENVVAR=CLIENT instructs
COMMAND to use to the current Emacs instance as \"the editor\",
assuming it respects ENVVAR as an \"EDITOR\"-like variable.
CLIENT may be the path to an appropriate emacsclient executable
with arguments, or a script which also works over Tramp.

Also see `async-shell-command' and `shell-command'.

(fn COMMAND &optional OUTPUT-BUFFER ERROR-BUFFER ENVVAR)" t nil) (autoload 'with-editor-shell-command "with-editor" "Like `shell-command' or `with-editor-async-shell-command'.
If COMMAND ends with \"&\" behave like the latter,
else like the former.

(fn COMMAND &optional OUTPUT-BUFFER ERROR-BUFFER ENVVAR)" t nil) (register-definition-prefixes "with-editor" '("server-" "shell-command--shell-command-with-editor-mode" "start-file-process--with-editor-process-filter" "with-editor")) (provide 'with-editor-autoloads)) "auth-source-pass" ((auth-source-pass auth-source-pass-autoloads) (autoload 'auth-source-pass-enable "auth-source-pass" "Enable auth-source-password-store." nil nil) (autoload 'auth-source-pass-get "auth-source-pass" "Return the value associated to KEY in the password-store entry ENTRY.

ENTRY is the name of a password-store entry.
The key used to retrieve the password is the symbol `secret'.

The convention used as the format for a password-store file is the
following (see URL `http://www.passwordstore.org/#organization'):

secret
key1: value1
key2: value2

(fn KEY ENTRY)" nil nil) (register-definition-prefixes "auth-source-pass" '("auth-source-pass-")) (provide 'auth-source-pass-autoloads)) "password-store" ((password-store-autoloads password-store) (autoload 'password-store-edit "password-store" "Edit password for ENTRY.

(fn ENTRY)" t nil) (autoload 'password-store-get "password-store" "Return password for ENTRY.

Returns the first line of the password data.
When CALLBACK is non-`NIL', call CALLBACK with the first line instead.

(fn ENTRY &optional CALLBACK)" nil nil) (autoload 'password-store-get-field "password-store" "Return FIELD for ENTRY.
FIELD is a string, for instance \"url\". 
When CALLBACK is non-`NIL', call it with the line associated to FIELD instead.
If FIELD equals to symbol secret, then this function reduces to `password-store-get'.

(fn ENTRY FIELD &optional CALLBACK)" nil nil) (autoload 'password-store-clear "password-store" "Clear secret in the kill ring.

Optional argument FIELD, a symbol or a string, describes
the stored secret to clear; if nil, then set it to 'secret.
Note, FIELD does not affect the function logic; it is only used
to display the message:

(message \"Field %s cleared.\" field).

(fn &optional FIELD)" t nil) (autoload 'password-store-copy "password-store" "Add password for ENTRY into the kill ring.

Clear previous password from the kill ring.  Pointer to the kill ring
is stored in `password-store-kill-ring-pointer'.  Password is cleared
after `password-store-time-before-clipboard-restore' seconds.

(fn ENTRY)" t nil) (autoload 'password-store-copy-field "password-store" "Add FIELD for ENTRY into the kill ring.

Clear previous secret from the kill ring.  Pointer to the kill ring is
stored in `password-store-kill-ring-pointer'.  Secret field is cleared
after `password-store-timeout' seconds.
If FIELD equals to symbol secret, then this function reduces to `password-store-copy'.

(fn ENTRY FIELD)" t nil) (autoload 'password-store-init "password-store" "Initialize new password store and use GPG-ID for encryption.

Separate multiple IDs with spaces.

(fn GPG-ID)" t nil) (autoload 'password-store-insert "password-store" "Insert a new ENTRY containing PASSWORD.

(fn ENTRY PASSWORD)" t nil) (autoload 'password-store-generate "password-store" "Generate a new password for ENTRY with PASSWORD-LENGTH.

Default PASSWORD-LENGTH is `password-store-password-length'.

(fn ENTRY &optional PASSWORD-LENGTH)" t nil) (autoload 'password-store-remove "password-store" "Remove existing password for ENTRY.

(fn ENTRY)" t nil) (autoload 'password-store-rename "password-store" "Rename ENTRY to NEW-ENTRY.

(fn ENTRY NEW-ENTRY)" t nil) (autoload 'password-store-version "password-store" "Show version of pass executable." t nil) (autoload 'password-store-url "password-store" "Browse URL stored in ENTRY.

(fn ENTRY)" t nil) (register-definition-prefixes "password-store" '("password-store-")) (provide 'password-store-autoloads)) "oauth2" ((oauth2-autoloads oauth2) (autoload 'oauth2-refresh-access "oauth2" "Refresh OAuth access TOKEN.
TOKEN should be obtained with `oauth2-request-access'.

(fn TOKEN)" nil nil) (autoload 'oauth2-auth "oauth2" "Authenticate application via OAuth2.

(fn AUTH-URL TOKEN-URL CLIENT-ID CLIENT-SECRET &optional SCOPE STATE REDIRECT-URI)" nil nil) (autoload 'oauth2-auth-and-store "oauth2" "Request access to a resource and store it using `plstore'.

(fn AUTH-URL TOKEN-URL SCOPE CLIENT-ID CLIENT-SECRET &optional REDIRECT-URI STATE)" nil nil) (autoload 'oauth2-url-retrieve-synchronously "oauth2" "Retrieve an URL synchronously using TOKEN to access it.
TOKEN can be obtained with `oauth2-auth'.

(fn TOKEN URL &optional REQUEST-METHOD REQUEST-DATA REQUEST-EXTRA-HEADERS)" nil nil) (autoload 'oauth2-url-retrieve "oauth2" "Retrieve an URL asynchronously using TOKEN to access it.
TOKEN can be obtained with `oauth2-auth'.  CALLBACK gets called with CBARGS
when finished.  See `url-retrieve'.

(fn TOKEN URL CALLBACK &optional CBARGS REQUEST-METHOD REQUEST-DATA REQUEST-EXTRA-HEADERS)" nil nil) (register-definition-prefixes "oauth2" '("oauth")) (provide 'oauth2-autoloads)) "all-the-icons-dired" ((all-the-icons-dired-autoloads all-the-icons-dired) (autoload 'all-the-icons-dired-mode "all-the-icons-dired" "Display all-the-icons icon for each files in a dired buffer.

This is a minor mode.  If called interactively, toggle the
`All-The-Icons-Dired mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `all-the-icons-dired-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (register-definition-prefixes "all-the-icons-dired" '("all-the-icons-dired-")) (provide 'all-the-icons-dired-autoloads)) "dired-single" ((dired-single-autoloads dired-single) (autoload 'dired-single-buffer "dired-single" "Visit selected directory in current buffer.

Visits the selected directory in the current buffer, replacing the
   current contents with the contents of the new directory.  This doesn't
   prevent you from having more than one dired buffer.  The main difference
   is that a given dired buffer will not spawn off a new buffer every time
   a new directory is visited.

If the variable `dired-single-use-magic-buffer' is non-nil, and the current
   buffer's name is the same as that specified by the variable
`dired-single-magic-buffer-name', then the new directory's buffer will retain
   that same name (i.e. not only will dired only use a single buffer, but
its name will not change every time a new directory is entered).

Optional argument DEFAULT-DIRNAME specifies the directory to visit; if not
specified, the directory or file on the current line is used (assuming it's
a dired buffer).  If the current line represents a file, the file is visited
in another window.

(fn &optional DEFAULT-DIRNAME)" t nil) (autoload 'dired-single-buffer-mouse "dired-single" "Mouse-initiated version of `dired-single-buffer' (which see).

Argument CLICK is the mouse-click event.

(fn CLICK)" t nil) (autoload 'dired-single-magic-buffer "dired-single" "Switch to buffer whose name is the value of `dired-single-magic-buffer-name'.

If no such buffer exists, launch dired in a new buffer and rename that buffer
to the value of `dired-single-magic-buffer-name'.  If the current buffer is the
magic buffer, it will prompt for a new directory to visit.

Optional argument DEFAULT-DIRNAME specifies the directory to visit (defaults to
the currently displayed directory).

(fn &optional DEFAULT-DIRNAME)" t nil) (autoload 'dired-single-toggle-buffer-name "dired-single" "Toggle between the 'magic' buffer name and the 'real' dired buffer name.

Will also seek to uniquify the 'real' buffer name." t nil) (autoload 'dired-single-up-directory "dired-single" "Like `dired-up-directory' but with `dired-single-buffer'.

(fn &optional OTHER-WINDOW)" t nil) (register-definition-prefixes "dired-single" '("dired-single-")) (provide 'dired-single-autoloads)) "dired-hacks-utils" ((dired-hacks-utils-autoloads dired-hacks-utils) (register-definition-prefixes "dired-hacks-utils" '("dired-")) (provide 'dired-hacks-utils-autoloads)) "dired-ranger" ((dired-ranger dired-ranger-autoloads) (autoload 'dired-ranger-copy "dired-ranger" "Place the marked items in the copy ring.

With non-nil prefix argument, add the marked items to the current
selection.  This allows you to gather files from multiple dired
buffers for a single paste.

(fn ARG)" t nil) (autoload 'dired-ranger-paste "dired-ranger" "Copy the items from copy ring to current directory.

With raw prefix argument \\[universal-argument], do not remove
the selection from the stack so it can be copied again.

With numeric prefix argument, copy the n-th selection from the
copy ring.

(fn ARG)" t nil) (autoload 'dired-ranger-move "dired-ranger" "Move the items from copy ring to current directory.

This behaves like `dired-ranger-paste' but moves the files
instead of copying them.

(fn ARG)" t nil) (autoload 'dired-ranger-bookmark "dired-ranger" "Bookmark current dired buffer.

CHAR is a single character (a-zA-Z0-9) representing the bookmark.
Reusing a bookmark replaces the content.  These bookmarks are not
persistent, they are used for quick jumping back and forth
between currently used directories.

(fn CHAR)" t nil) (autoload 'dired-ranger-bookmark-visit "dired-ranger" "Visit bookmark CHAR.

If the associated dired buffer was killed, we try to reopen it
according to the setting `dired-ranger-bookmark-reopen'.

The special bookmark `dired-ranger-bookmark-LRU' always jumps to
the least recently visited dired buffer.

See also `dired-ranger-bookmark'.

(fn CHAR)" t nil) (register-definition-prefixes "dired-ranger" '("dired-ranger-")) (provide 'dired-ranger-autoloads)) "dired-collapse" ((dired-collapse-autoloads dired-collapse) (autoload 'dired-collapse-mode "dired-collapse" "Toggle collapsing of unique nested paths in Dired.

This is a minor mode.  If called interactively, toggle the
`Dired-Collapse mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `dired-collapse-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (register-definition-prefixes "dired-collapse" '("dired-collapse")) (provide 'dired-collapse-autoloads)) "dired-rainbow" ((dired-rainbow dired-rainbow-autoloads) (register-definition-prefixes "dired-rainbow" '("dired-rainbow-")) (provide 'dired-rainbow-autoloads)) "openwith" ((openwith openwith-autoloads) (defvar openwith-mode nil "Non-nil if Openwith mode is enabled.
See the `openwith-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `openwith-mode'.") (custom-autoload 'openwith-mode "openwith" nil) (autoload 'openwith-mode "openwith" "Automatically open files with external programs.

This is a minor mode.  If called interactively, toggle the
`Openwith mode' mode.  If the prefix argument is positive, enable
the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='openwith-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (register-definition-prefixes "openwith" '("openwith-")) (provide 'openwith-autoloads)) "org" ((org-attach ob-ebnf ox-org org-indent org-list org-install ob-io ob-abc ob-sql ob-lisp ob-calc ob-sass org-protocol ob-shen org-faces ob-perl ob-table org-plot ol-irc ox ob-eshell ob-ref org-attach-git ol-gnus ob-ocaml ol ol-info ob-dot org-loaddefs ob-ditaa ol-eww ox-beamer ol-eshell ob-screen ol-rmail ob org-colview ob-makefile ol-bbdb ob-ruby ox-md org-goto org-pcomplete org-lint ob-plantuml ob-latex org-inlinetask ob-exp ob-ledger ob-mscgen ob-shell ob-sed ob-maxima org-crypt ob-vala ob-clojure org-mouse ob-C org-datetree org-tempo ox-texinfo org-archive ob-lua org-timer ob-css org-id ob-sqlite ol-bibtex org-num org-duration ob-lob ob-coq ob-hledger ox-icalendar ob-octave ob-fortran ob-scheme ob-groovy ol-mhe org-feed org-ctags org-macro org-mobile org-element ol-w3m ol-docview ob-asymptote ob-processing ox-html org-table ob-python org-entities ob-lilypond ox-odt ob-comint org-agenda ob-java ob-forth ob-picolisp ob-emacs-lisp org-macs ob-tangle ox-latex org-keys ob-stan org-footnote org-clock org-compat ob-awk org-src ob-matlab ox-man ob-eval ob-R ob-core org-capture ox-ascii ox-publish org-habit ob-org ob-J org-version org-refile org ob-gnuplot ob-haskell ob-js)) "org-superstar" ((org-superstar-autoloads org-superstar) (put 'org-superstar-leading-bullet 'safe-local-variable #'char-or-string-p) (autoload 'org-superstar-toggle-lightweight-lists "org-superstar" "Toggle syntax checking for plain list items.

Disabling syntax checking will cause Org Superstar to display
lines looking like plain lists (for example in code) like plain
lists.  However, this may cause significant speedup for org files
containing several hundred list items." t nil) (autoload 'org-superstar-mode "org-superstar" "Use UTF8 bullets for headlines and plain lists.

This is a minor mode.  If called interactively, toggle the
`Org-Superstar mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `org-superstar-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (register-definition-prefixes "org-superstar" '("org-superstar-")) (provide 'org-superstar-autoloads)) "org-pomodoro" ((org-pomodoro org-pomodoro-pidgin org-pomodoro-autoloads) (autoload 'org-pomodoro "org-pomodoro" "Start a new pomodoro or stop the current one.

When no timer is running for `org-pomodoro` a new pomodoro is started and
the current task is clocked in.  Otherwise EMACS will ask whether we\302\264d like to
kill the current timer, this may be a break or a running pomodoro.

(fn &optional ARG)" t nil) (register-definition-prefixes "org-pomodoro" '("org-pomodoro-")) (register-definition-prefixes "org-pomodoro-pidgin" '("org-pom")) (provide 'org-pomodoro-autoloads)) "evil-org" ((evil-org evil-org-autoloads evil-org-agenda) (autoload 'evil-org-mode "evil-org" "Buffer local minor mode for evil-org

This is a minor mode.  If called interactively, toggle the
`Evil-Org mode' mode.  If the prefix argument is positive, enable
the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `evil-org-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (register-definition-prefixes "evil-org" '("evil-org-")) (register-definition-prefixes "evil-org-agenda" '("evil-org-agenda-set-keys")) (provide 'evil-org-autoloads)) "org-make-toc" ((org-make-toc org-make-toc-autoloads) (autoload 'org-make-toc "org-make-toc" "Make or update table of contents in current buffer." t nil) (autoload 'org-make-toc-at-point "org-make-toc" "Make or update table of contents at current entry." t nil) (autoload 'org-make-toc-insert "org-make-toc" "Insert \":CONTENTS:\" drawer at point." t nil) (autoload 'org-make-toc-set "org-make-toc" "Set TOC PROPERTIES of entry at point.

(fn PROPERTIES)" t nil) (autoload 'org-make-toc-mode "org-make-toc" "Add the `org-make-toc' command to the `before-save-hook' in the current Org buffer.
With prefix argument ARG, turn on if positive, otherwise off.

(fn &optional ARG)" t nil) (register-definition-prefixes "org-make-toc" '("org-make-toc-")) (provide 'org-make-toc-autoloads)) "org-present" ((org-present org-present-autoloads) (autoload 'org-present "org-present" "init." t nil) (register-definition-prefixes "org-present" '("org-present-")) (provide 'org-present-autoloads)) "emacsql" ((emacsql-autoloads emacsql-compiler emacsql) (autoload 'emacsql-show-last-sql "emacsql" "Display the compiled SQL of the s-expression SQL expression before point.
A prefix argument causes the SQL to be printed into the current buffer.

(fn &optional PREFIX)" t nil) (register-definition-prefixes "emacsql" '("emacsql-")) (register-definition-prefixes "emacsql-compiler" '("emacsql-")) (provide 'emacsql-autoloads)) "emacsql-sqlite3" ((emacsql-sqlite3 emacsql-sqlite3-autoloads) (register-definition-prefixes "emacsql-sqlite3" '("emacsql-sqlite3-")) (provide 'emacsql-sqlite3-autoloads)) "org-roam" ((org-roam-capture org-roam-db org-roam-protocol org-roam-autoloads org-roam-link org-roam-faces org-roam-buffer org-roam-dev org-roam-doctor org-roam-completion org-roam org-roam-macs org-roam-compat org-roam-graph org-roam-dailies) (defvar org-roam-mode nil "Non-nil if Org-roam mode is enabled.
See the `org-roam-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `org-roam-mode'.") (custom-autoload 'org-roam-mode "org-roam" nil) (autoload 'org-roam-mode "org-roam" "Minor mode for Org-roam.

This mode sets up several hooks, to ensure that the cache is updated on file
changes, renames and deletes. It is also in charge of graceful termination of
the database connection.

When called interactively, toggle `org-roam-mode'. with prefix
ARG, enable `org-roam-mode' if ARG is positive, otherwise disable
it.

When called from Lisp, enable `org-roam-mode' if ARG is omitted,
nil, or positive. If ARG is `toggle', toggle `org-roam-mode'.
Otherwise, behave as if called interactively.

(fn &optional ARG)" t nil) (defalias 'org-roam 'org-roam-buffer-toggle-display) (autoload 'org-roam-diagnostics "org-roam" "Collect and print info for `org-roam' issues." t nil) (autoload 'org-roam-find-file "org-roam" "Find and open an Org-roam file.
INITIAL-PROMPT is the initial title prompt.
COMPLETIONS is a list of completions to be used instead of
`org-roam--get-title-path-completions`.
FILTER-FN is the name of a function to apply on the candidates
which takes as its argument an alist of path-completions.  See
`org-roam--get-title-path-completions' for details.
If NO-CONFIRM, assume that the user does not want to modify the initial prompt.

(fn &optional INITIAL-PROMPT COMPLETIONS FILTER-FN NO-CONFIRM)" t nil) (autoload 'org-roam-find-directory "org-roam" "Find and open `org-roam-directory'." t nil) (autoload 'org-roam-find-ref "org-roam" "Find and open an Org-roam file from a ref.
ARG is used to forward interactive calls to
`org-roam--get-ref-path-completions'
FILTER can either be a string or a function:
- If it is a string, it should be the type of refs to include as
candidates (e.g. \"cite\" ,\"website\" ,etc.)
- If it is a function, it should be the name of a function that
takes three arguments: the type, the ref, and the file of the
current candidate.  It should return t if that candidate is to be
included as a candidate.

(fn ARG &optional FILTER)" t nil) (autoload 'org-roam-random-note "org-roam" "Find a random Org-roam file." t nil) (autoload 'org-roam-insert "org-roam" "Find an Org-roam file, and insert a relative org link to it at point.
Return selected file if it exists.
If LOWERCASE is non-nil, downcase the link description.
LINK-TYPE is the type of link to be created. It defaults to \"file\".
COMPLETIONS is a list of completions to be used instead of
`org-roam--get-title-path-completions`.
FILTER-FN is the name of a function to apply on the candidates
which takes as its argument an alist of path-completions.
If DESCRIPTION is provided, use this as the link label.  See
`org-roam--get-title-path-completions' for details.

(fn &optional LOWERCASE COMPLETIONS FILTER-FN DESCRIPTION LINK-TYPE)" t nil) (autoload 'org-roam-insert-immediate "org-roam" "Find an Org-roam file, and insert a relative org link to it at point.
This variant of `org-roam-insert' inserts the link immediately by
using the template in `org-roam-capture-immediate-template'. The
interactive ARG and ARGS are passed to `org-roam-insert'.
See `org-roam-insert' for details.

(fn ARG &rest ARGS)" t nil) (autoload 'org-roam-find-file-immediate "org-roam" "Find and open an Org-roam file.
This variant of `org-roam-find-file' uses the template in
`org-roam-capture-immediate-template', avoiding the capture
process. The interactive ARG and ARGS are passed to
`org-roam-find-file'. See `org-roam-find-file' for details.

(fn ARG &rest ARGS)" t nil) (autoload 'org-roam-jump-to-index "org-roam" "Find the index file in `org-roam-directory'.
The path to the index can be defined in `org-roam-index-file'.
Otherwise, the function will look in your `org-roam-directory'
for a note whose title is 'Index'.  If it does not exist, the
command will offer you to create one." t nil) (autoload 'org-roam-alias-add "org-roam" "Add an alias to Org-roam file.

Return added alias." t nil) (autoload 'org-roam-alias-delete "org-roam" "Delete an alias from Org-roam file." t nil) (autoload 'org-roam-switch-to-buffer "org-roam" "Switch to an existing Org-roam buffer." t nil) (autoload 'org-roam-version "org-roam" "Return `org-roam' version.
Interactively, or when MESSAGE is non-nil, show in the echo area.

(fn &optional MESSAGE)" t nil) (register-definition-prefixes "org-roam" '("org-roam-")) (register-definition-prefixes "org-roam-buffer" '("org-roam-buffer")) (autoload 'org-roam-capture "org-roam-capture" "Launches an `org-capture' process for a new or existing note.
This uses the templates defined at `org-roam-capture-templates'.
Arguments GOTO and KEYS see `org-capture'.

(fn &optional GOTO KEYS)" t nil) (register-definition-prefixes "org-roam-capture" '("org-roam-capture-")) (register-definition-prefixes "org-roam-completion" '("org-roam-completion-")) (register-definition-prefixes "org-roam-dailies" '("org-roam-dailies-")) (register-definition-prefixes "org-roam-db" '("org-roam-db")) (autoload 'org-roam-dev-mode "org-roam-dev" "Minor mode for setting the dev environment of Org-roam.

This is a minor mode.  If called interactively, toggle the
`Org-Roam-Dev mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `org-roam-dev-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t nil) (autoload 'org-roam-doctor "org-roam-doctor" "Perform a check on the current buffer to ensure cleanliness.
If CHECKALL, run the check for all Org-roam files.

(fn &optional CHECKALL)" t nil) (register-definition-prefixes "org-roam-doctor" '("org-roam-doctor-")) (autoload 'org-roam-graph "org-roam-graph" "Build and possibly display a graph for FILE from NODE-QUERY.
If FILE is nil, default to current buffer's file name.
ARG may be any of the following values:
  - nil       show the graph.
  - `\\[universal-argument]'     show the graph for FILE.
  - `\\[universal-argument]' N   show the graph for FILE limiting nodes to N steps.
  - `\\[universal-argument] \\[universal-argument]' build the graph.
  - `\\[universal-argument]' -   build the graph for FILE.
  - `\\[universal-argument]' -N  build the graph for FILE limiting nodes to N steps.

(fn &optional ARG FILE NODE-QUERY)" t nil) (register-definition-prefixes "org-roam-graph" '("org-roam-graph-")) (register-definition-prefixes "org-roam-link" '("org-roam-link-")) (register-definition-prefixes "org-roam-macs" '("org-roam-")) (register-definition-prefixes "org-roam-protocol" '("org-roam-protocol-")) (provide 'org-roam-autoloads)) "geiser" ((geiser-repl geiser-syntax geiser-version geiser-custom geiser-company geiser-autoloads geiser-eval geiser-doc geiser-reload geiser-chibi geiser-chicken geiser-connection geiser-edit geiser-table geiser-chez geiser-impl geiser-guile geiser-debug geiser-mit geiser-autodoc geiser-racket geiser-completion geiser-log geiser-menu geiser-mode geiser-gambit geiser-popup geiser-image geiser geiser-xref geiser-compile geiser-base) (defconst geiser-elisp-dir (file-name-directory load-file-name) "Directory containing Geiser's Elisp files.") (defconst geiser-scheme-dir (let ((d (expand-file-name "./scheme/" geiser-elisp-dir))) (if (file-directory-p d) d (expand-file-name "../scheme/" geiser-elisp-dir))) "Directory containing Geiser's Scheme files.") (add-to-list 'load-path (directory-file-name geiser-elisp-dir)) (autoload 'geiser-version "geiser-version" "Echo Geiser's version." t) (autoload 'geiser-unload "geiser-reload" "Unload all Geiser code." t) (autoload 'geiser-reload "geiser-reload" "Reload Geiser code." t) (autoload 'geiser "geiser-repl" "Start a Geiser REPL, or switch to a running one." t) (autoload 'run-geiser "geiser-repl" "Start a Geiser REPL." t) (autoload 'geiser-connect "geiser-repl" "Start a Geiser REPL connected to a remote server." t) (autoload 'geiser-connect-local "geiser-repl" "Start a Geiser REPL connected to a remote server over a Unix-domain socket." t) (autoload 'switch-to-geiser "geiser-repl" "Switch to a running one Geiser REPL." t) (autoload 'run-chez "geiser-chez" "Start a Geiser Chez REPL." t) (autoload 'switch-to-chez "geiser-chez" "Start a Geiser Chez REPL, or switch to a running one." t) (autoload 'run-guile "geiser-guile" "Start a Geiser Guile REPL." t) (autoload 'switch-to-guile "geiser-guile" "Start a Geiser Guile REPL, or switch to a running one." t) (autoload 'connect-to-guile "geiser-guile" "Connect to a remote Geiser Guile REPL." t) (autoload 'run-gambit "geiser-gambit" "Start a Geiser Gambit REPL." t) (autoload 'switch-to-gambit "geiser-gambit" "Start a Geiser Gambit REPL, or switch to a running one." t) (autoload 'connect-to-gambit "geiser-gambit" "Connect to a remote Geiser Gambit REPL." t) (autoload 'run-racket "geiser-racket" "Start a Geiser Racket REPL." t) (autoload 'run-gracket "geiser-racket" "Start a Geiser GRacket REPL." t) (autoload 'switch-to-racket "geiser-racket" "Start a Geiser Racket REPL, or switch to a running one." t) (autoload 'connect-to-racket "geiser-racket" "Connect to a remote Geiser Racket REPL." t) (autoload 'run-chicken "geiser-chicken" "Start a Geiser Chicken REPL." t) (autoload 'switch-to-chicken "geiser-chicken" "Start a Geiser Chicken REPL, or switch to a running one." t) (autoload 'connect-to-chicken "geiser-chicken" "Connect to a remote Geiser Chicken REPL." t) (autoload 'run-mit "geiser-mit" "Start a Geiser MIT/GNU Scheme REPL." t) (autoload 'switch-to-mit "geiser-mit" "Start a Geiser MIT/GNU Scheme REPL, or switch to a running one." t) (autoload 'run-chibi "geiser-chibi" "Start a Geiser Chibi Scheme REPL." t) (autoload 'switch-to-chibi "geiser-chibi" "Start a Geiser Chibi Scheme REPL, or switch to a running one." t) (autoload 'geiser-mode "geiser-mode" "Minor mode adding Geiser REPL interaction to Scheme buffers." t) (autoload 'turn-on-geiser-mode "geiser-mode" "Enable Geiser's mode (useful in Scheme buffers)." t) (autoload 'turn-off-geiser-mode "geiser-mode" "Disable Geiser's mode (useful in Scheme buffers)." t) (autoload 'geiser-mode--maybe-activate "geiser-mode") (mapc (lambda (group) (custom-add-load group (symbol-name group)) (custom-add-load 'geiser (symbol-name group))) '(geiser geiser-repl geiser-autodoc geiser-doc geiser-debug geiser-faces geiser-mode geiser-guile geiser-gambit geiser-image geiser-racket geiser-chicken geiser-chez geiser-chibi geiser-mit geiser-implementation geiser-xref)) (add-hook 'scheme-mode-hook 'geiser-mode--maybe-activate) (add-to-list 'auto-mode-alist '("\\.rkt\\'" . scheme-mode)) (register-definition-prefixes "geiser-autodoc" '("geiser-autodoc-")) (register-definition-prefixes "geiser-base" '("geiser--")) (register-definition-prefixes "geiser-chez" '("chez" "geiser-chez-")) (register-definition-prefixes "geiser-chibi" '("chibi" "geiser-chibi-")) (register-definition-prefixes "geiser-chicken" '("chicken" "connect-to-chicken" "geiser-chicken")) (register-definition-prefixes "geiser-company" '("geiser-company--")) (register-definition-prefixes "geiser-compile" '("geiser-")) (register-definition-prefixes "geiser-completion" '("geiser-")) (register-definition-prefixes "geiser-connection" '("geiser-con")) (register-definition-prefixes "geiser-custom" '("geiser-custom-")) (register-definition-prefixes "geiser-debug" '("geiser-debug-")) (register-definition-prefixes "geiser-doc" '("geiser-doc-")) (register-definition-prefixes "geiser-edit" '("geiser-")) (register-definition-prefixes "geiser-eval" '("geiser-eval--")) (register-definition-prefixes "geiser-gambit" '("connect-to-gambit" "gambit" "geiser-gambit-")) (register-definition-prefixes "geiser-guile" '("connect-to-guile" "geiser-guile-" "guile")) (register-definition-prefixes "geiser-image" '("geiser-")) (register-definition-prefixes "geiser-impl" '("define-geiser-implementation" "geiser-" "with--geiser-implementation")) (register-definition-prefixes "geiser-log" '("geiser-")) (register-definition-prefixes "geiser-menu" '("geiser-menu--")) (register-definition-prefixes "geiser-mit" '("geiser-mit-" "mit")) (register-definition-prefixes "geiser-mode" '("geiser-" "turn-o")) (register-definition-prefixes "geiser-popup" '("geiser-popup-")) (register-definition-prefixes "geiser-racket" '("connect-to-racket" "geiser-racket-" "racket" "run-gracket")) (register-definition-prefixes "geiser-reload" '("geiser-")) (register-definition-prefixes "geiser-repl" '("geiser" "run-geiser" "switch-to-geiser")) (register-definition-prefixes "geiser-syntax" '("geiser-syntax--")) (register-definition-prefixes "geiser-table" '("geiser-table-")) (register-definition-prefixes "geiser-version" '("geiser-version")) (register-definition-prefixes "geiser-xref" '("geiser-xref-")) (provide 'geiser-autoloads)) "bui" ((bui-button bui-core bui-entry bui-history bui-autoloads bui-info bui bui-list bui-utils) (register-definition-prefixes "bui" '("bui-define-")) (register-definition-prefixes "bui-button" '("bui")) (register-definition-prefixes "bui-core" '("bui-")) (register-definition-prefixes "bui-entry" '("bui-")) (register-definition-prefixes "bui-history" '("bui-history")) (register-definition-prefixes "bui-info" '("bui-info-")) (register-definition-prefixes "bui-list" '("bui-list-")) (register-definition-prefixes "bui-utils" '("bui-")) (provide 'bui-autoloads)) "magit-popup" ((magit-popup-autoloads magit-popup) (register-definition-prefixes "magit-popup" '("magit-")) (provide 'magit-popup-autoloads)) "edit-indirect" ((edit-indirect edit-indirect-autoloads) (autoload 'edit-indirect-region "edit-indirect" "Edit the region BEG..END in a separate buffer.
The region is copied, without text properties, to a separate
buffer, called edit-indirect buffer, and
`edit-indirect-guess-mode-function' is called to set the major
mode.
When done, exit with `edit-indirect-commit', which will remove the
original region and replace it with the edited version; or with
`edit-indirect-abort', which will drop the modifications.

This differs from `clone-indirect-buffer' with narrowing in that
the text properties are not shared, so the parent buffer major mode
and the edit-indirect buffer major mode will not be able to tread
on each other's toes by setting up potentially conflicting text
properties, which happens surprisingly often when the font-lock
mode is used.

Edit-indirect buffers use the `edit-indirect-mode-map' keymap.

If there's already an edit-indirect buffer for BEG..END, use that.
If there's already an edit-indirect buffer active overlapping any
portion of BEG..END, an `edit-indirect-overlapping' error is
signaled.

When DISPLAY-BUFFER is non-nil or when called interactively,
display the edit-indirect buffer in some window and select it.

In any case, return the edit-indirect buffer.

(fn BEG END &optional DISPLAY-BUFFER)" t nil) (register-definition-prefixes "edit-indirect" '("edit-indirect-")) (provide 'edit-indirect-autoloads)) "guix" ((guix-ui-system-generation guix-about guix-command guix-ui-profile guix-ui-generation guix-default-config guix-auto-mode guix-devel guix-license guix-location guix-external guix-derivation guix-pcomplete guix-ui-messages guix-help guix-ui-license guix-read guix-ui-package guix-profiles guix-package guix-help-vars guix-autoloads guix-scheme guix-misc guix-ui-service guix-hash guix-ui-store-item guix-graph guix-guile guix-build-log guix-geiser guix-ui-system guix-env-var guix-popup guix-ui-lint-checker guix-config guix-ui-package-location guix-service guix-repl guix-utils guix-ui guix-ui-service-location guix-prettify guix) (autoload 'guix-version "guix-about" "Display Emacs-Guix and Guix versions in the echo area." t nil) (autoload 'guix-about "guix-about" "Display 'About' buffer with fancy Guix logo if available.
Switch to `guix-about-buffer-name' buffer if it already exists." t nil) (register-definition-prefixes "guix-about" '("guix-")) (defvar guix-store-directory "/gnu/store" "Name of the Guix store directory.
See Info node `(guix) The Store'.

This string is used in various regular expressions and it
shouldn't end with a trailing slash.") (defvar guix-hash-regexp (rx (= 32 (any "0-9" "a-d" "f-n" "p-s" "v-z"))) "Regexp matching hash part of a store file name.") (unless (rassq 'guix-build-log-mode auto-mode-alist) (let ((chars-rx (rx (+ (any alnum "-_+."))))) (setq auto-mode-alist (append `((,(rx-to-string `(and "/guix/drvs/" (= 2 alnum) "/" (= 30 alnum) "-" (regexp ,chars-rx) ".drv" string-end) t) . guix-build-log-mode) (,(rx-to-string `(and ,guix-store-directory "/" (regexp ,chars-rx) ".drv" string-end) t) . guix-derivation-mode) (,(rx-to-string `(and "/etc/profile" string-end) t) . guix-env-var-mode) (,(rx-to-string `(and "/tmp/guix-build-" (regexp ,chars-rx) ".drv-" (one-or-more digit) "/environment-variables" string-end) t) . guix-env-var-mode) (,(rx-to-string `(and "/guix/profiles/system" (* (regexp ,chars-rx)) "/" (or "boot" "parameters") string-end) t) . guix-scheme-mode) (,(rx-to-string `(and ,guix-store-directory "/" (regexp ,guix-hash-regexp) "-" (or "activate" "activate-service" "boot" "parameters" "shepherd.conf" (and "shepherd" (regexp ,chars-rx) ".scm") (and (regexp ,chars-rx) "-guile-builder")) string-end) t) . guix-scheme-mode)) auto-mode-alist)))) (autoload 'guix-build-log-mode "guix-build-log" "Major mode for viewing Guix build logs.

\\{guix-build-log-mode-map}

(fn)" t nil) (autoload 'guix-build-log-minor-mode "guix-build-log" "Toggle Guix Build Log minor mode.

With a prefix argument ARG, enable Guix Build Log minor mode if
ARG is positive, and disable it otherwise.  If called from Lisp,
enable the mode if ARG is omitted or nil.

When Guix Build Log minor mode is enabled, it highlights build
log in the current buffer.  This mode can be enabled
programmatically using hooks, like this:

  (add-hook 'shell-mode-hook 'guix-build-log-minor-mode)

\\{guix-build-log-minor-mode-map}

(fn &optional ARG)" t nil) (register-definition-prefixes "guix-build-log" '("guix-build-log-")) (autoload 'guix-command "guix-command" "Popup window for 'guix' shell commands." t) (register-definition-prefixes "guix-command" '("guix-")) (register-definition-prefixes "guix-config" '("guix-")) (register-definition-prefixes "guix-default-config" '("guix-config-")) (autoload 'guix-derivation-mode "guix-derivation" "Major mode for viewing Guix derivations.

\\{guix-derivation-mode-map}

(fn)" t nil) (register-definition-prefixes "guix-derivation" '("guix-derivation-")) (autoload 'guix-devel-code-block-edit "guix-devel" "Edit the current synopsis/description in `texinfo-mode'." t nil) (autoload 'guix-devel-mode "guix-devel" "Minor mode for `scheme-mode' buffers.

With a prefix argument ARG, enable the mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable the mode
if ARG is omitted or nil.

When Guix Devel mode is enabled, it highlights various Guix
keywords.  This mode can be enabled programmatically using hooks,
like this:

  (add-hook 'scheme-mode-hook 'guix-devel-mode)

\\{guix-devel-mode-map}

(fn &optional ARG)" t nil) (register-definition-prefixes "guix-devel" '("guix-devel-")) (autoload 'guix-env-var-prettify-variable "guix-env-var" "Prettify shell environment variable at current line." t nil) (autoload 'guix-env-var-prettify-buffer "guix-env-var" "Prettify BUFFER with `guix-env-var-prettify-variable'.
Interactively, or if BUFFER is not specified, use the current buffer.

(fn &optional BUFFER)" t nil) (autoload 'guix-env-var-mode "guix-env-var" "Major mode for viewing Guix environment-variables and profile files.

\\{guix-env-var-mode-map}

(fn)" t nil) (register-definition-prefixes "guix-env-var" '("guix-env-var-")) (register-definition-prefixes "guix-external" '("guix-")) (register-definition-prefixes "guix-geiser" '("guix-geiser-")) (autoload 'guix-package-graph "guix-graph" "Show BACKEND/NODE-TYPE graph for a PACKAGE.
PACKAGE can be either a package name or a package ID.
Interactively, prompt for arguments.

(fn PACKAGE BACKEND NODE-TYPE)" t nil) (register-definition-prefixes "guix-graph" '("guix-")) (register-definition-prefixes "guix-guile" '("guix-")) (autoload 'guix-hash "guix-hash" "Calculate and copy (put into `kill-ring') the hash of FILE.

If FILE is a directory, calculate its hash recursively excluding
version-controlled files.

Interactively, prompt for FILE (see also `guix-support-dired').
With prefix argument, prompt for FORMAT as well.

See also Info node `(guix) Invoking guix hash'.

(fn FILE &optional FORMAT)" t nil) (autoload 'guix-info "guix-help" "Show Emacs-Guix info manual.
If ARG is non-nil (interactively with prefix), show Guix info manual.

(fn &optional ARG)" t nil) (autoload 'guix-help "guix-help" "Display a summary of the available Emacs-Guix commands.
Switch to `guix-help-buffer-name' buffer if it already exists." t nil) (autoload 'guix-switch-to-buffer "guix-help" "Switch to BUFFER.
Interactively, prompt for BUFFER completing only Guix buffer names.
Guix buffers are defined using `guix-define-buffer-function'.

(fn BUFFER)" t nil) (autoload 'guix-extended-command "guix-help" "Run Emacs-Guix COMMAND.
This is like '\\[execute-extended-command]' but only global Guix
commands are completed (commands displayed with '\\[guix-help]').

(fn COMMAND)" t nil) (register-definition-prefixes "guix-help" '("guix-")) (register-definition-prefixes "guix-help-vars" '("guix-")) (autoload 'guix-find-license-location-file "guix-license" "Open FILE with license definitions.
See `guix-license-file' for the meaning of DIRECTORY.
Interactively, with prefix argument, prompt for DIRECTORY.

(fn &optional DIRECTORY)" t nil) (autoload 'guix-find-license-definition "guix-license" "Open licenses file from DIRECTORY and move to the LICENSE definition.
See `guix-license-file' for the meaning of DIRECTORY.
Interactively, with prefix argument, prompt for DIRECTORY.

(fn LICENSE &optional DIRECTORY)" t nil) (autoload 'guix-browse-license-url "guix-license" "Browse URL of a LICENSE.

(fn LICENSE)" t nil) (register-definition-prefixes "guix-license" '("guix-l")) (register-definition-prefixes "guix-location" '("guix-")) (autoload 'guix-apply-manifest "guix-misc" "Apply manifest from FILE to PROFILE.
This function has the same meaning as 'guix package --manifest' command.
See Info node `(guix) Invoking guix package' for details.

Interactively, use the current profile and prompt for manifest
FILE.  With a prefix argument, also prompt for PROFILE.

(fn PROFILE FILE &optional OPERATION-BUFFER)" t nil) (autoload 'guix-set-emacs-environment "guix-misc" "Set Emacs environment to match PROFILE.
PROFILE can be a named profile (like '~/.guix-profile',
'~/.config/guix/work') or a direct link to profile from the
store, like GUIX_ENVIRONMENT variable (see Info node `(guix)
Invoking guix environment' for details).

If PROFILE is nil, use `guix-current-profile'.

(fn &optional PROFILE)" t nil) (autoload 'guix-pull "guix-misc" "Run Guix pull operation.
If VERBOSE is non-nil (with prefix argument), produce verbose output.

(fn &optional VERBOSE)" t nil) (autoload 'guix-report-bug "guix-misc" "Report GNU Guix bug.
Prompt for bug subject and open a mail buffer.

(fn SUBJECT)" t nil) (register-definition-prefixes "guix-misc" '("guix-")) (autoload 'guix-package-size "guix-package" "Show size of PACKAGE-OR-FILE.
PACKAGE-OR-FILE should be either a package name or a store file name.
TYPE should be on of the following symbols: `text' (default) or `image'.
Interactively, prompt for a package name and size TYPE.

(fn PACKAGE-OR-FILE &optional TYPE)" t nil) (autoload 'guix-package-lint "guix-package" "Lint PACKAGES using CHECKERS.
PACKAGES is a list of package names.
CHECKERS is a list of checker names; if nil, use all checkers.

Interactively, prompt for PACKAGES and use all checkers.
With prefix argument, also prompt for checkers (should be comma
separated).

See Info node `(guix) Invoking guix lint' for details about linting.

(fn PACKAGES &optional CHECKERS)" t nil) (defalias 'guix-lint 'guix-package-lint) (autoload 'guix-find-package-location-file "guix-package" "Open package location FILE.
See `guix-find-location' for the meaning of DIRECTORY.

Interactively, prompt for the location FILE.  With prefix
argument, prompt for DIRECTORY as well.

(fn FILE &optional DIRECTORY)" t nil) (autoload 'guix-find-package-definition "guix-package" "Go to the location of package with ID-OR-NAME.
See `guix-find-location' for the meaning of package location and
DIRECTORY.
Interactively, with prefix argument, prompt for DIRECTORY.

(fn ID-OR-NAME &optional DIRECTORY)" t nil) (defalias 'guix-edit 'guix-find-package-definition) (register-definition-prefixes "guix-package" '("guix-")) (autoload 'pcomplete/guix "guix-pcomplete" "Completion for `guix'." nil nil) (register-definition-prefixes "guix-pcomplete" '("guix-pcomplete-")) (autoload 'guix-popup "guix-popup" nil t) (defalias 'guix #'guix-popup "Popup interface for Emacs-Guix commands.") (register-definition-prefixes "guix-popup" '("guix-p")) (autoload 'guix-prettify-mode "guix-prettify" "Toggle Guix Prettify mode.

With a prefix argument ARG, enable Guix Prettify mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

When Guix Prettify mode is enabled, hash parts of the Guix store
file names (see `guix-prettify-regexp') are displayed as
`guix-prettify-char' character, i.e.:

  /gnu/store/\342\200\246-foo-0.1  instead of:
  /gnu/store/72f54nfp6g1hz873w8z3gfcah0h4nl9p-foo-0.1

This mode can be enabled programmatically using hooks:

  (add-hook 'shell-mode-hook 'guix-prettify-mode)

It is possible to enable the mode in any buffer, however not any
buffer's highlighting may survive after adding new elements to
`font-lock-keywords' (see `guix-prettify-special-modes' for
details).

Also you can use `global-guix-prettify-mode' to enable Guix
Prettify mode for all modes that support font-locking.

(fn &optional ARG)" t nil) (put 'global-guix-prettify-mode 'globalized-minor-mode t) (defvar global-guix-prettify-mode nil "Non-nil if Global Guix-Prettify mode is enabled.
See the `global-guix-prettify-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-guix-prettify-mode'.") (custom-autoload 'global-guix-prettify-mode "guix-prettify" nil) (autoload 'global-guix-prettify-mode "guix-prettify" "Toggle Guix-Prettify mode in all buffers.
With prefix ARG, enable Global Guix-Prettify mode if ARG is positive; otherwise,
disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Guix-Prettify mode is enabled in all buffers where `guix-prettify-turn-on' would
do it.

See `guix-prettify-mode' for more information on Guix-Prettify mode.

(fn &optional ARG)" t nil) (defalias 'guix-prettify-global-mode 'global-guix-prettify-mode) (register-definition-prefixes "guix-prettify" '("guix-prettify-")) (autoload 'guix-set-current-profile "guix-profiles" "Set `guix-current-profile' to FILE-NAME.
Interactively, prompt for FILE-NAME.  With prefix, use
`guix-user-profile'.

(fn FILE-NAME)" t nil) (register-definition-prefixes "guix-profiles" '("guix-")) (register-definition-prefixes "guix-read" '("guix-")) (register-definition-prefixes "guix-repl" '("guix-")) (autoload 'guix-scheme-mode "guix-scheme" "Major mode for editing Scheme code.
This mode is the same as `scheme-mode', except it also reindents
the current buffer after it is enabled.

(fn)" t nil) (register-definition-prefixes "guix-scheme" '("guix-scheme-display-message")) (autoload 'guix-find-service-location-file "guix-service" "Open service location FILE.
See `guix-find-location' for the meaning of DIRECTORY.

Interactively, prompt for the location FILE.  With prefix
argument, prompt for DIRECTORY as well.

(fn FILE &optional DIRECTORY)" t nil) (autoload 'guix-find-service-definition "guix-service" "Go to the location of service with ID-OR-NAME.
See `guix-find-location' for the meaning of location and
DIRECTORY.
Interactively, with prefix argument, prompt for DIRECTORY.

(fn ID-OR-NAME &optional DIRECTORY)" t nil) (register-definition-prefixes "guix-service" '("guix-service-location")) (register-definition-prefixes "guix-ui" '("guix-ui-")) (autoload 'guix-generations "guix-ui-generation" "Display information about all generations.
If PROFILE is nil, use `guix-current-profile'.
Interactively with prefix, prompt for PROFILE.

(fn &optional PROFILE)" t nil) (autoload 'guix-last-generations "guix-ui-generation" "Display information about last NUMBER generations.
If PROFILE is nil, use `guix-current-profile'.
Interactively with prefix, prompt for PROFILE.

(fn NUMBER &optional PROFILE)" t nil) (autoload 'guix-generations-by-time "guix-ui-generation" "Display information about generations created between FROM and TO.
FROM and TO should be time values.
If PROFILE is nil, use `guix-current-profile'.
Interactively with prefix, prompt for PROFILE.

(fn FROM TO &optional PROFILE)" t nil) (register-definition-prefixes "guix-ui-generation" '("guix-")) (autoload 'guix-licenses "guix-ui-license" "Display licenses of the Guix packages.
Switch to the `guix-license-list-buffer-name' buffer if it
already exists." t nil) (register-definition-prefixes "guix-ui-license" '("guix-license")) (autoload 'guix-lint-checkers "guix-ui-lint-checker" "Display lint checkers of the Guix packages.
TYPE should be one of the following symbols: `all', `local', `network'.
Interactively, with prefix argument, prompt for TYPE.

(fn &optional TYPE)" t nil) (register-definition-prefixes "guix-ui-lint-checker" '("guix-lint-checker-")) (register-definition-prefixes "guix-ui-messages" '("guix-")) (autoload 'guix-packages-by-name "guix-ui-package" "Display Guix packages with NAME.
NAME is a string with name specification.  It may optionally contain
a version number.  Examples: \"guile\", \"guile@2.0.11\".

If PROFILE is nil, use `guix-current-profile'.
Interactively with prefix, prompt for PROFILE.

(fn NAME &optional PROFILE)" t nil) (autoload 'guix-packages-by-regexp "guix-ui-package" "Search for Guix packages by REGEXP.
PARAMS are package parameters that should be searched.
If PARAMS are not specified, use `guix-package-search-params'.

If PROFILE is nil, use `guix-current-profile'.
Interactively with prefix, prompt for PROFILE.

(fn REGEXP &optional PARAMS PROFILE)" t nil) (define-obsolete-function-alias 'guix-search-by-regexp 'guix-packages-by-regexp "0.5.3") (autoload 'guix-packages-by-name-regexp "guix-ui-package" "Search for Guix packages matching REGEXP in a package name.
If PROFILE is nil, use `guix-current-profile'.
Interactively with prefix, prompt for PROFILE.

(fn REGEXP &optional PROFILE)" t nil) (define-obsolete-function-alias 'guix-search-by-name 'guix-packages-by-name-regexp "0.5.3") (autoload 'guix-packages-by-license "guix-ui-package" "Display Guix packages with LICENSE.
LICENSE is a license name string.
If PROFILE is nil, use `guix-current-profile'.
Interactively with prefix, prompt for PROFILE.

(fn LICENSE &optional PROFILE)" t nil) (autoload 'guix-packages-by-location "guix-ui-package" "Display Guix packages placed in LOCATION file.
If PROFILE is nil, use `guix-current-profile'.
Interactively with prefix, prompt for PROFILE.

(fn LOCATION &optional PROFILE)" t nil) (autoload 'guix-package-from-file "guix-ui-package" "Display Guix package that the code from FILE evaluates to.
If PROFILE is nil, use `guix-current-profile'.
Interactively prompt for FILE (see also `guix-support-dired').
With prefix argument, prompt for PROFILE as well.

(fn FILE &optional PROFILE)" t nil) (autoload 'guix-packages-from-system-config-file "guix-ui-package" "Display Guix packages from the operating system configuration FILE.

Make sure FILE has a proper 'operating-system' declaration.  You
may check it, for example, by running the following shell command:

  guix system build --dry-run FILE

See also Info node `(guix) System Configuration'.

If PROFILE is nil, use system profile (it is used to show what
packages from FILE are installed in PROFILE).

Interactively, prompt for FILE (see also `guix-support-dired').
With prefix argument, prompt for PROFILE as well.

Note: This command displays only those packages that are placed
in 'packages' field of the 'operating-system' declaration.  An
installed system also contains packages installed by
services (like 'guix' or 'shepherd').  To see all the packages
installed in a system profile, use
'\\[guix-installed-system-packages]' command.

(fn FILE &optional PROFILE)" t nil) (autoload 'guix-installed-packages "guix-ui-package" "Display information about installed Guix packages.
If PROFILE is nil, use `guix-current-profile'.
Interactively with prefix, prompt for PROFILE.

(fn &optional PROFILE)" t nil) (autoload 'guix-installed-user-packages "guix-ui-package" "Display information about Guix packages installed in a user profile." t nil) (autoload 'guix-installed-system-packages "guix-ui-package" "Display information about Guix packages installed in a system profile." t nil) (autoload 'guix-obsolete-packages "guix-ui-package" "Display information about obsolete (or unknown) Guix packages.
If PROFILE is nil, use `guix-current-profile'.
Interactively with prefix, prompt for PROFILE.

(fn &optional PROFILE)" t nil) (autoload 'guix-superseded-packages "guix-ui-package" "Display information about superseded Guix packages.
If PROFILE is nil, use `guix-current-profile'.
Interactively with prefix, prompt for PROFILE.

(fn &optional PROFILE)" t nil) (autoload 'guix-dependent-packages "guix-ui-package" "Display Guix packages that depend on PACKAGES.
This is similar to 'guix refresh --list-dependent PACKAGES ...'.
See Info node `(guix) Invoking guix refresh' for details.

TYPE should be a symbol `all' or `direct'.  Interactively, prompt
for it.

If PROFILE is nil, use `guix-current-profile'.
Interactively with prefix, prompt for PROFILE.

(fn PACKAGES &optional TYPE PROFILE)" t nil) (autoload 'guix-hidden-packages "guix-ui-package" "Display hidden Guix packages.
If PROFILE is nil, use `guix-current-profile'.

(fn &optional PROFILE)" t nil) (autoload 'guix-all-packages "guix-ui-package" "Display all available Guix packages.
If PROFILE is nil, use `guix-current-profile'.
Interactively with prefix, prompt for PROFILE.

(fn &optional PROFILE)" t nil) (define-obsolete-function-alias 'guix-newest-packages 'guix-all-packages "0.5.2") (autoload 'guix-number-of-packages "guix-ui-package" "Display the number of available Guix packages.
This number includes the packages from GUIX_PACKAGE_PATH (see
Info node `(guix) Package Modules')." t nil) (register-definition-prefixes "guix-ui-package" '("guix-")) (autoload 'guix-package-locations "guix-ui-package-location" "Display locations of the Guix packages.
Switch to the `guix-package-location-list-buffer-name' buffer if
it already exists." t nil) (define-obsolete-function-alias 'guix-locations 'guix-package-locations "0.4") (register-definition-prefixes "guix-ui-package-location" '("guix-package-location")) (autoload 'guix-profiles "guix-ui-profile" "Display Guix profiles.
Switch to the `guix-profile-list-buffer-name' buffer if it
already exists.

Modify `guix-profiles' variable to add more profiles." t nil) (autoload 'guix-system-profile "guix-ui-profile" "Display interface for `guix-system-profile'." t nil) (autoload 'guix-current-profile "guix-ui-profile" "Display interface for `guix-current-profile'." t nil) (register-definition-prefixes "guix-ui-profile" '("guix-")) (autoload 'guix-services-from-system-config-file "guix-ui-service" "Display Guix services from the operating system configuration FILE.
See `guix-packages-from-system-config-file' for more details on FILE.
Interactively, prompt for FILE (see also `guix-support-dired').

(fn FILE)" t nil) (autoload 'guix-all-services "guix-ui-service" "Display all available Guix services." t nil) (autoload 'guix-default-services "guix-ui-service" "Display Guix services from VAR-NAME.
VAR-NAME is a name of the variable from
`guix-default-services-variables'.

(fn VAR-NAME)" t nil) (autoload 'guix-services-by-name "guix-ui-service" "Display Guix service(s) with NAME.

(fn NAME)" t nil) (autoload 'guix-services-by-regexp "guix-ui-service" "Search for Guix services by REGEXP.
PARAMS are service parameters that should be searched.
If PARAMS are not specified, use `guix-service-search-params'.

(fn REGEXP &optional PARAMS)" t nil) (autoload 'guix-services-by-location "guix-ui-service" "Display Guix services placed in LOCATION file.

(fn LOCATION)" t nil) (register-definition-prefixes "guix-ui-service" '("guix-")) (autoload 'guix-service-locations "guix-ui-service-location" "Display locations of the Guix services.
Switch to the `guix-service-location-list-buffer-name' buffer if
it already exists." t nil) (register-definition-prefixes "guix-ui-service-location" '("guix-service-location")) (autoload 'guix-store-item "guix-ui-store-item" "Display store items with FILE-NAMES.
Interactively, prompt for a single file name.

(fn &rest FILE-NAMES)" t nil) (autoload 'guix-store-item-referrers "guix-ui-store-item" "Display referrers of the FILE-NAMES store item.
This is analogous to 'guix gc --referrers FILE-NAMES' shell
command.  See Info node `(guix) Invoking guix gc'.

(fn &rest FILE-NAMES)" t nil) (autoload 'guix-store-item-references "guix-ui-store-item" "Display references of the FILE-NAMES store item.
This is analogous to 'guix gc --references FILE-NAMES' shell
command.  See Info node `(guix) Invoking guix gc'.

(fn &rest FILE-NAMES)" t nil) (autoload 'guix-store-item-requisites "guix-ui-store-item" "Display requisites of the FILE-NAMES store item.
This is analogous to 'guix gc --requisites FILE-NAMES' shell
command.  See Info node `(guix) Invoking guix gc'.

(fn &rest FILE-NAMES)" t nil) (autoload 'guix-store-item-derivers "guix-ui-store-item" "Display derivers of the FILE-NAMES store item.
This is analogous to 'guix gc --derivers FILE-NAMES' shell
command.  See Info node `(guix) Invoking guix gc'.

(fn &rest FILE-NAMES)" t nil) (autoload 'guix-store-failures "guix-ui-store-item" "Display store items corresponding to cached build failures.
This is analogous to 'guix gc --list-failures' shell command.
See Info node `(guix) Invoking guix gc'." t nil) (autoload 'guix-store-live-items "guix-ui-store-item" "Display live store items.
This is analogous to 'guix gc --list-live' shell command.
See Info node `(guix) Invoking guix gc'." t nil) (autoload 'guix-store-dead-items "guix-ui-store-item" "Display dead store items.
This is analogous to 'guix gc --list-dead' shell command.
See Info node `(guix) Invoking guix gc'." t nil) (register-definition-prefixes "guix-ui-store-item" '("guix-")) (autoload 'guix-system-from-file "guix-ui-system" "Display info on 'operating-system' declaration from FILE.
See `guix-packages-from-system-config-file' for more details on FILE.
Interactively, prompt for FILE (see also `guix-support-dired').

(fn FILE)" t nil) (register-definition-prefixes "guix-ui-system" '("guix-system-")) (autoload 'guix-system-generations "guix-ui-system-generation" "Display information about system generations." t nil) (autoload 'guix-last-system-generations "guix-ui-system-generation" "Display information about last NUMBER of system generations.

(fn NUMBER)" t nil) (autoload 'guix-system-generations-by-time "guix-ui-system-generation" "Display information about system generations created between FROM and TO.

(fn FROM TO)" t nil) (register-definition-prefixes "guix-ui-system-generation" '("guix-system-generation-")) (register-definition-prefixes "guix-utils" '("guix-")) (provide 'guix-autoloads)) "daemons" ((daemons-sysvinit daemons-systemd daemons-autoloads daemons-brew daemons-shepherd daemons-openrc daemons) (autoload 'daemons-status "daemons" "Show the status of the daemon NAME.

(fn NAME)" t nil) (autoload 'daemons-start "daemons" "Start the daemon NAME.  Show results in an output buffer.

(fn NAME)" t nil) (autoload 'daemons-stop "daemons" "Stop the daemon NAME.  Show results in an output buffer.

(fn NAME)" t nil) (autoload 'daemons-restart "daemons" "Restart the daemon NAME.  Show results in an ouptut buffer.

(fn NAME)" t nil) (autoload 'daemons-reload "daemons" "Reload the daemon NAME.  Show results in an output buffer.

(fn NAME)" t nil) (autoload 'daemons-enable "daemons" "Enable the daemon NAME.  Show results in an output buffer.

(fn NAME)" t nil) (autoload 'daemons-disable "daemons" "Disable the daemon NAME.  Show results in an output buffer.

(fn NAME)" t nil) (autoload 'daemons "daemons" "Open the list of system daemons (services) for user management.

This opens a \342\200\230daemons-mode\342\200\231 list buffer.  Move the cursor to a daemon line and
execute one of the commands in `describe-mode' to show status and manage the
state of the daemon." t nil) (register-definition-prefixes "daemons" '("daemons-")) (register-definition-prefixes "daemons-brew" '("daemons-brew--")) (register-definition-prefixes "daemons-openrc" '("daemons-openrc--")) (register-definition-prefixes "daemons-shepherd" '("daemons-shepherd--")) (register-definition-prefixes "daemons-systemd" '("daemons-systemd-")) (register-definition-prefixes "daemons-sysvinit" '("daemons-sysvinit--")) (provide 'daemons-autoloads)) "pulseaudio-control" ((pulseaudio-control pulseaudio-control-autoloads) (autoload 'pulseaudio-control-decrease-volume "pulseaudio-control" "Decrease volume of currently-selected Pulse sink.

Amount of decrease is specified by `pulseaudio-control-volume-step'." t nil) (autoload 'pulseaudio-control-default-keybindings "pulseaudio-control" "Make `C-x /' the prefix for accessing pulseaudio-control bindings." t nil) (autoload 'pulseaudio-control-display-volume "pulseaudio-control" "Display volume of currently-selected Pulse sink." t nil) (autoload 'pulseaudio-control-increase-volume "pulseaudio-control" "Increase volume of currently-selected Pulse sink.

Amount of increase is specified by `pulseaudio-control-volume-step'." t nil) (autoload 'pulseaudio-control-select-sink-by-index "pulseaudio-control" "Select which Pulse sink to act on, by numeric index.

Accepts number as prefix argument.

Argument SINK is the number provided by the user." t nil) (autoload 'pulseaudio-control-select-sink-by-name "pulseaudio-control" "Select which Pulse sink to act on, by name." t nil) (autoload 'pulseaudio-control-set-volume "pulseaudio-control" "Set volume of currently-selected Pulse sink.

The value can be:

* a percentage, e.g. '10%';
* in decibels, e.g. '2dB';
* a linear factor, e.g. '0.9' or '1.1'.

Argument VOLUME is the volume provided by the user.

(fn VOLUME)" t nil) (autoload 'pulseaudio-control-toggle-current-sink-mute "pulseaudio-control" "Toggle muting of currently-selected Pulse sink." t nil) (autoload 'pulseaudio-control-toggle-current-source-mute "pulseaudio-control" "Toggle muting of currently-selected Pulse source." t nil) (autoload 'pulseaudio-control-toggle-sink-mute-by-index "pulseaudio-control" "Toggle muting of Pulse sink, specified by index.

Argument SINK is the number provided by the user.

(fn SINK)" t nil) (autoload 'pulseaudio-control-toggle-sink-mute-by-name "pulseaudio-control" "Toggle muting of Pulse sink, specified by name." t nil) (autoload 'pulseaudio-control-toggle-use-of-default-sink "pulseaudio-control" "Toggle use of @DEFAULT_SINK@ for volume operations." t nil) (register-definition-prefixes "pulseaudio-control" '("pulseaudio-control-")) (provide 'pulseaudio-control-autoloads))))

#s(hash-table size 65 test eq rehash-size 1.5 rehash-threshold 0.8125 data (org-elpa #s(hash-table size 97 test equal rehash-size 1.5 rehash-threshold 0.8125 data (version 11 "melpa" nil "gnu-elpa-mirror" nil "el-get" nil "emacsmirror-mirror" nil "straight" nil "use-package" nil "bind-key" nil "setup" nil "no-littering" nil "cl-lib" nil "undo-tree" nil "evil" nil "goto-chg" nil "evil-collection" nil "annalist" nil "diminish" nil "which-key" nil "general" nil "spacegray-theme" nil "doom-themes" nil "emojify" nil "seq" nil "ht" nil "dash" nil "minions" nil "doom-modeline" nil "all-the-icons" nil "shrink-path" nil "s" nil "f" nil "perspective" nil "alert" nil "gntp" nil "log4e" nil "super-save" nil "evil-nerd-commenter" nil "ws-butler" nil "parinfer" nil "origami" nil "dotcrafter" nil "hydra" nil "lv" nil "corfu" nil "orderless" nil "consult" nil "marginalia" nil "embark" nil "avy" nil "bufler" nil "dash-functional" nil "pretty-hydra" nil "magit-section" nil "default-text-scale" nil "ace-window" nil "visual-fill-column" nil "popper" nil "password-store" nil "with-editor" nil "auth-source-pass" nil "oauth2" nil "all-the-icons-dired" nil "dired-single" nil "dired-ranger" nil "dired-hacks-utils" nil "dired-collapse" nil "dired-rainbow" nil "openwith" nil "org" (org :type git :repo "https://git.savannah.gnu.org/git/emacs/org-mode.git" :local-repo "org" :depth full :pre-build (straight-recipes-org-elpa--build) :build (:not autoloads) :files (:defaults "lisp/*.el" ("etc/styles/" "etc/styles/*"))) "org-superstar" nil "org-pomodoro" nil "evil-org" nil "org-make-toc" nil "org-present" nil "org-roam" nil "emacsql" nil "emacsql-sqlite3" nil "guix" nil "geiser" nil "bui" nil "magit-popup" nil "edit-indirect" nil "daemons" nil "pulseaudio-control" nil)) melpa #s(hash-table size 97 test equal rehash-size 1.5 rehash-threshold 0.8125 data (version 2 "gnu-elpa-mirror" nil "el-get" (el-get :type git :flavor melpa :files ("*.el" ("recipes" "recipes/el-get.rcp") "methods" "el-get-pkg.el") :host github :repo "dimitri/el-get") "emacsmirror-mirror" nil "straight" nil "use-package" (use-package :type git :flavor melpa :files (:defaults (:exclude "bind-key.el" "bind-chord.el" "use-package-chords.el" "use-package-ensure-system-package.el") "use-package-pkg.el") :host github :repo "jwiegley/use-package") "bind-key" (bind-key :type git :flavor melpa :files ("bind-key.el" "bind-key-pkg.el") :host github :repo "jwiegley/use-package") "setup" nil "no-littering" (no-littering :type git :flavor melpa :host github :repo "emacscollective/no-littering") "cl-lib" nil "undo-tree" nil "evil" (evil :type git :flavor melpa :files (:defaults "doc/build/texinfo/evil.texi" (:exclude "evil-test-helpers.el") "evil-pkg.el") :host github :repo "emacs-evil/evil") "goto-chg" (goto-chg :type git :flavor melpa :host github :repo "emacs-evil/goto-chg") "evil-collection" (evil-collection :type git :flavor melpa :files (:defaults "modes" "evil-collection-pkg.el") :host github :repo "emacs-evil/evil-collection") "annalist" (annalist :type git :flavor melpa :host github :repo "noctuid/annalist.el") "diminish" (diminish :type git :flavor melpa :host github :repo "myrjola/diminish.el") "which-key" (which-key :type git :flavor melpa :host github :repo "justbur/emacs-which-key") "general" (general :type git :flavor melpa :host github :repo "noctuid/general.el") "spacegray-theme" (spacegray-theme :type git :flavor melpa :host github :repo "bruce/emacs-spacegray-theme") "doom-themes" (doom-themes :type git :flavor melpa :files (:defaults "themes/*.el" "doom-themes-pkg.el") :host github :repo "hlissner/emacs-doom-themes") "emojify" (emojify :type git :flavor melpa :files (:defaults "data" "images" "emojify-pkg.el") :host github :repo "iqbalansari/emacs-emojify") "seq" nil "ht" (ht :type git :flavor melpa :files ("ht.el" "ht-pkg.el") :host github :repo "Wilfred/ht.el") "dash" (dash :type git :flavor melpa :files ("dash.el" "dash.texi" "dash-pkg.el") :host github :repo "magnars/dash.el") "minions" (minions :type git :flavor melpa :host github :repo "tarsius/minions") "doom-modeline" (doom-modeline :type git :flavor melpa :host github :repo "seagle0128/doom-modeline") "all-the-icons" (all-the-icons :type git :flavor melpa :files (:defaults "data" "all-the-icons-pkg.el") :host github :repo "domtronn/all-the-icons.el") "shrink-path" (shrink-path :type git :flavor melpa :host gitlab :repo "bennya/shrink-path.el") "s" (s :type git :flavor melpa :files ("s.el" "s-pkg.el") :host github :repo "magnars/s.el") "f" (f :type git :flavor melpa :files ("f.el" "f-pkg.el") :host github :repo "rejeep/f.el") "perspective" (perspective :type git :flavor melpa :host github :repo "nex3/perspective-el") "alert" (alert :type git :flavor melpa :host github :repo "jwiegley/alert") "gntp" (gntp :type git :flavor melpa :host github :repo "tekai/gntp.el") "log4e" (log4e :type git :flavor melpa :host github :repo "aki2o/log4e") "super-save" (super-save :type git :flavor melpa :host github :repo "bbatsov/super-save") "evil-nerd-commenter" (evil-nerd-commenter :type git :flavor melpa :host github :repo "redguardtoo/evil-nerd-commenter") "ws-butler" (ws-butler :type git :flavor melpa :host github :repo "lewang/ws-butler") "parinfer" (parinfer :type git :flavor melpa :host github :repo "DogLooksGood/parinfer-mode") "origami" (origami :type git :flavor melpa :host github :repo "gregsexton/origami.el") "dotcrafter" nil "hydra" (hydra :type git :flavor melpa :files (:defaults (:exclude "lv.el") "hydra-pkg.el") :host github :repo "abo-abo/hydra") "lv" (lv :type git :flavor melpa :files ("lv.el" "lv-pkg.el") :host github :repo "abo-abo/hydra") "corfu" nil "orderless" (orderless :type git :flavor melpa :host github :repo "oantolin/orderless") "consult" (consult :type git :flavor melpa :files (:defaults (:exclude "consult-flycheck.el" "consult-selectrum.el") "consult-pkg.el") :host github :repo "minad/consult") "marginalia" (marginalia :type git :flavor melpa :host github :repo "minad/marginalia") "embark" (embark :type git :flavor melpa :files ("embark.el" "embark-pkg.el") :host github :repo "oantolin/embark") "avy" (avy :type git :flavor melpa :host github :repo "abo-abo/avy") "bufler" (bufler :type git :flavor melpa :files (:defaults (:exclude "helm-bufler.el") "bufler-pkg.el") :host github :repo "alphapapa/bufler.el") "dash-functional" (dash-functional :type git :flavor melpa :files ("dash-functional.el" "dash-functional-pkg.el") :host github :repo "magnars/dash.el") "pretty-hydra" (pretty-hydra :type git :flavor melpa :files ("pretty-hydra.el" "pretty-hydra-pkg.el") :host github :repo "jerrypnz/major-mode-hydra.el") "magit-section" (magit-section :type git :flavor melpa :files ("lisp/magit-section.el" "Documentation/magit-section.texi" "magit-section-pkg.el") :host github :repo "magit/magit") "default-text-scale" (default-text-scale :type git :flavor melpa :host github :repo "purcell/default-text-scale") "ace-window" (ace-window :type git :flavor melpa :host github :repo "abo-abo/ace-window") "visual-fill-column" (visual-fill-column :type git :flavor melpa :host github :repo "joostkremers/visual-fill-column") "popper" nil "password-store" (password-store :type git :flavor melpa :files ("contrib/emacs/*.el" "password-store-pkg.el") :host github :repo "zx2c4/password-store") "with-editor" (with-editor :type git :flavor melpa :host github :repo "magit/with-editor") "auth-source-pass" (auth-source-pass :type git :flavor melpa :host github :repo "DamienCassou/auth-source-pass") "oauth2" nil "all-the-icons-dired" (all-the-icons-dired :type git :flavor melpa :host github :repo "jtbm37/all-the-icons-dired") "dired-single" (dired-single :type git :flavor melpa :host github :repo "crocket/dired-single") "dired-ranger" (dired-ranger :type git :flavor melpa :files ("dired-ranger.el" "dired-ranger-pkg.el") :host github :repo "Fuco1/dired-hacks") "dired-hacks-utils" (dired-hacks-utils :type git :flavor melpa :files ("dired-hacks-utils.el" "dired-hacks-utils-pkg.el") :host github :repo "Fuco1/dired-hacks") "dired-collapse" (dired-collapse :type git :flavor melpa :files ("dired-collapse.el" "dired-collapse-pkg.el") :host github :repo "Fuco1/dired-hacks") "dired-rainbow" (dired-rainbow :type git :flavor melpa :files ("dired-rainbow.el" "dired-rainbow-pkg.el") :host github :repo "Fuco1/dired-hacks") "openwith" (openwith :type git :flavor melpa :host github :repo "jpkotta/openwith") "org-superstar" (org-superstar :type git :flavor melpa :host github :repo "integral-dw/org-superstar-mode") "org-pomodoro" (org-pomodoro :type git :flavor melpa :files (:defaults "resources" "org-pomodoro-pkg.el") :host github :repo "marcinkoziej/org-pomodoro") "evil-org" (evil-org :type git :flavor melpa :host github :repo "Somelauw/evil-org-mode") "org-make-toc" (org-make-toc :type git :flavor melpa :host github :repo "alphapapa/org-make-toc") "org-present" (org-present :type git :flavor melpa :host github :repo "rlister/org-present") "org-roam" (org-roam :type git :flavor melpa :host github :repo "org-roam/org-roam") "emacsql" (emacsql :type git :flavor melpa :files ("emacsql.el" "emacsql-compiler.el" "emacsql-system.el" "README.md" "emacsql-pkg.el") :host github :repo "skeeto/emacsql") "emacsql-sqlite3" (emacsql-sqlite3 :type git :flavor melpa :host github :repo "cireu/emacsql-sqlite3") "guix" (guix :type git :flavor melpa :files ("elisp/*.el" "doc/*.texi" ("images" "images/*.svg") ("scheme" "scheme/*") (:exclude "scheme/Makefile.am") "guix-pkg.el") :host github :repo "alezost/guix.el") "geiser" (geiser :type git :flavor melpa :files ("elisp/*.el" "elisp/geiser-version.el.in" "doc/*.texi" ("bin" "bin/*") (:exclude "bin/Makefile.am") ("scheme" "scheme/*") (:exclude "scheme/Makefile.am") "geiser-pkg.el") :host gitlab :repo "jaor/geiser") "bui" (bui :type git :flavor melpa :host github :repo "alezost/bui.el") "magit-popup" (magit-popup :type git :flavor melpa :host github :repo "magit/magit-popup") "edit-indirect" (edit-indirect :type git :flavor melpa :host github :repo "Fanael/edit-indirect") "daemons" (daemons :type git :flavor melpa :host github :repo "cbowdon/daemons.el") "pulseaudio-control" (pulseaudio-control :type git :flavor melpa :host github :repo "flexibeast/pulseaudio-control"))) gnu-elpa-mirror #s(hash-table size 65 test equal rehash-size 1.5 rehash-threshold 0.8125 data (version 3 "emacsmirror-mirror" nil "straight" nil "setup" nil "cl-lib" nil "undo-tree" (undo-tree :type git :host github :repo "emacs-straight/undo-tree" :files ("*" (:exclude ".git"))) "seq" nil "dotcrafter" nil "corfu" nil "popper" nil "oauth2" (oauth2 :type git :host github :repo "emacs-straight/oauth2" :files ("*" (:exclude ".git"))))) el-get #s(hash-table size 65 test equal rehash-size 1.5 rehash-threshold 0.8125 data (version 1 "emacsmirror-mirror" nil "straight" nil "setup" `(setup :type git :host github :repo "zk-phi/setup" :files (:defaults)) "cl-lib" nil "seq" nil "dotcrafter" nil "corfu" nil "popper" nil)) emacsmirror-mirror #s(hash-table size 65 test equal rehash-size 1.5 rehash-threshold 0.8125 data (version 2 "straight" (straight :type git :host github :repo "emacsmirror/straight") "cl-lib" nil "seq" nil "dotcrafter" nil "corfu" nil "popper" nil))))

("org-elpa" "melpa" "gnu-elpa-mirror" "el-get" "emacsmirror-mirror" "straight" "emacs" "use-package" "bind-key" "setup" "no-littering" "cl-lib" "undo-tree" "evil" "goto-chg" "evil-collection" "annalist" "diminish" "which-key" "general" "spacegray-theme" "doom-themes" "emojify" "seq" "ht" "dash" "minions" "doom-modeline" "all-the-icons" "shrink-path" "s" "f" "perspective" "alert" "gntp" "log4e" "super-save" "evil-nerd-commenter" "ws-butler" "parinfer" "origami" "dotcrafter" "hydra" "lv" "corfu" "orderless" "consult" "marginalia" "embark" "avy" "bufler" "dash-functional" "pretty-hydra" "magit-section" "default-text-scale" "ace-window" "visual-fill-column" "popper" "password-store" "with-editor" "auth-source-pass" "oauth2" "nadvice" "all-the-icons-dired" "dired-single" "dired-ranger" "dired-hacks-utils" "dired-collapse" "dired-rainbow" "openwith" "org" "org-superstar" "org-pomodoro" "evil-org" "org-make-toc" "org-present" "org-roam" "emacsql" "emacsql-sqlite3" "guix" "geiser" "bui" "magit-popup" "edit-indirect" "daemons" "pulseaudio-control")

t
